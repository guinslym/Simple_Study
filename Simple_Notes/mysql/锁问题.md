##Mysql锁概论##
相对于其他数据库而言,Mysql的锁机制比较简单,其最显著的特点是不同的存储引擎支持不同的锁机制。比如,MyISAM和MEMORY存储引擎采用的是表级锁,BDB存储引擎采用的是页面锁,但也支持表级锁;Innodb存储引擎既支持行级锁,也支持表级锁,但默认情况下是采用行级锁。  
Mysql这3种锁的特性大致归纳如下:

- 表级锁:开销小,加锁快。不会出现死锁,锁定粒度大,发生锁冲突的概率最高,并发度最低。
- 行级锁:开销大,加锁慢。会出现死锁,锁定粒度最小,发生锁冲突的概论最低,并发度也最高。
- 页面锁:开销和加锁时间介于表锁和行锁之间,会出现死锁,锁定粒度介于表锁和行锁之间,并发度一般。

##MyISAM表锁##
###查询表级锁争用情况###
可以通过检查`table_locks_waited`和`table_locks_immediate`状态变量来分析系统上的表锁定争夺。如果`table_locks_waited`的值比较高,则说明存在较严重的表级锁争用情况。
###MySQL表级锁的锁模式###
MyISAM表的读操作,不会阻塞其他用户对同1表的读请求,但会阻塞对通过1表的写请求:对MyISAM表的写操作,则会阻塞其他用户对同1表的读和写操作。  
MyISAM表的读操作和写操作之间,以及写操作之间是串行的。当1个线程获得对1个表的写锁后,只有持锁的线程可以对表进行更新操作。其他线程的读写操作都会等待,直到锁被释放为止。  
MyISAM在执行查询语句前,会自动给涉及的所有表加读锁,在执行更新操作前,会自动给涉及的表加写锁,这个过程不需要用户干预,因此用户一般不需要直接用LOCKTABLE命令给MyISAM表显式加锁。  
给MyISAM表显式加锁,一般是为了在一定程序上模拟事务操作,实现对某一时间点多个表的一致性读取。例如,有1个订单表orders,其中记录有各订单的总金额total,同时还有1个订单明细表order_detail,其中记录有各订单每1产品的金额小计subtotal,假设我们需要检查这2个表的金额合计是否相符,可能就需要执行如下2条SQL:

```
select sum(total) from orders;
select sum(subtotal) from order_detail;
```

这时,如果不先给2个表加锁,就可能产生错误的结果,因为第1条语句执行过程中,order_detail表可能已经发生了改变。因此,正确的方法应该是:

```
Lock tables orders read local,order_detail read local;
select sum(total) from orders;
select sum(subtotal) from order_detail;
Unlock tables;
```

要特别说明以下2点:

- 上面的例子在LOCK TABLES时加上local选项,其作用就是在满足MyISAM表并发插入条件的情况下,允许其他用户在表尾并发插入记录。
- 在用LOCKTABLES给表显式加表锁时,必须同时取出所有涉及表的锁,并且Mysql不支持锁升级。也就是说,在执行LOCK TABLES后,只能访问显式加锁的这些表,不能访问未加锁的表。同时,如果加的是读锁,那么只能执行查询操作,而不能执行更新操作。其实,在自动加锁的情况下也基本如此,MyISAM总是1次获得SQL语句所需要的全部锁。这也是MyISAM表不会出现死锁的原因。并发

###并发插入###
在一定条件下,MyISAM表也支持查询和插入操作的并发进行。  
MyISAM存储引擎有1个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别为0,1和2.

- 当concurrent_insert设置为0时,不允许并发插入。
- 当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在1个进程读表的同时,另1个进程从表尾插入记录。
- 当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录。

###MyISAM的锁调度###
前面讲过,MyiSAM存储引擎的读锁和写锁是互斥的,读写操作是串行的。那么,1个进程请求某个MyISAM表的读锁,同时另1个进程也请求同1个表的写锁,Mysql如何处理?答案是写进程先获得锁。不仅如此,即使读请求先到锁等待队列,写请求后到,写锁也会插到读锁请求之前。这是因为Mysql认为写请求一般比读请求要重要。我们可以通过一些设置来调节MyISAM的调度行为:

- 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
- 通过执行命令set LOW_PRIORITY_UPDATES=1，该连接发出的更新请求优先级降低。
- 通过指定insert、update、delete语句的LOW_PRTORITY属性,降低该语句的优先级。

另外,Mysql也提供了1种折衷的办法来调节读写冲突,即给系统参数`max_write_lock_count`设置1个合适的值,当1个表的读锁达到这个值后,Mysql就暂时将写请求的优先级降低,给读进程一定获得锁的机会。

##Innodb锁问题##
###并发事务处理带来的问题###
相对于串行处理来说,并发事务处理能大大增加数据库资源的利用率,提供数据库系统的事务吞吐量,从而可以支持更多的用户。但并发事务处理也会带来一些问题,主要包括以下几种情况:

- 更新丢失：当2个或多个事务选择同1行,然后基于最初选定的值更新该行时,由于每个事务都不知道其他事务的存在,就会发生丢失更新问题。最后的更新覆盖了由其他事务所做的更新。
- 脏读:1个事务正在对1条记录做修改,在这个事务完成并提交前,这条记录的数据就处于不一致状态。这时,另1个事务也来读取同1条记录,如果不加控制,第2个事务读取了这些脏数据,并据此做进一步的处理,就会产生未提交的数据依赖关系。这种现象被形象地叫做脏读。
- 不可重复读:1个事务在读取某些数据后的某个时间,再次读取以前读过的数据,却发现其读出的数据已经发生了改变,或某些记录已经被删除了的现象。
- 幻读:1个事务按相同的查询条件重新读取以前检索过的数据,却发现其他事务插入了满足其查询条件的新数据的现象。

###获得Innodb行锁争用情况###
通过`InnoDB_row_lock`状态变量来分析系统上的行锁的争夺情况.  
如果发现锁争用比较严重,如`InnoDB_row_lock_waits`和`InnoDB_row_lock_time_avg`的值比较高,还可以设置`InnoDB Monitors`来进一步观察发生锁冲突的表、数据行等,并分析锁争用的原因。  
具体方法如下:

```
create table innodb_monitor(a int) engine=Innodb;
show innodb status\G;
```

###InnoDB的行锁模式及加锁模式###

- 共享锁:允许1个事务去读一行,阻止其他事务获得相同数据集的排他锁。
- 排他锁:允许获得排他锁的事务更新数据,阻止其他事务取得相同的数据集的共享读锁和排他写锁。
- 意向共享锁:事务打算给数据行加行共享锁,事务在给1个数据行加共享锁前必须先取得该表的IS(意向共享锁)锁。
- 意向排他锁:事务打算给数据行加行排他锁,事务在给1个数据行加排他锁前必须先取得该表的IX(意向排他锁)锁。

意向锁是InnoDB自动加的,不需用户干预。对于update、delete和insert语句,InnoDB会自动给涉及数据集加排他锁。对于普通select语句,InnoDB不会加任何锁。事务可以通过以下语句显示给记录集加共享锁或排他锁:

- 共享锁:select * from table_name where ... lock in share mode;
- 排他锁:select * from table_name where ... for update;

###Innodb行锁实现方式###
InnoDB行锁是通过给索引上的索引项加锁实现实现的,而Oracle是通过在数据块中对相应数据行加锁来实现的。这意味着:只有通过索引条件检索数据,Innodb才使用行级锁。否则,Innodb使用表锁。  

当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论是使用主键索引、唯一索引或普通索引,Innodb都会使用行锁来对数据加锁。

###间隙锁(Next-Key锁)###
对于键值在条件范围内但并不存在的记录,叫做间隙(GAP).Innodb对这个间隙加锁的锁机制就是所谓的间隙锁。  
举例来说,假如emp表只有101条记录,其empid的值分别为1,2,...,101,下面语句:

```
select * from emp where empid >100 for update;
```

是1个范围条件的检索,InnodB不仅会对符合条件的empid值为101的记录加锁,也会对empid大于101的间隙加锁。  
InnodB使用间隙锁的目的,一方面是为了防止幻读,以满足相关隔离级别的的要求,对于上面的例子,要是不使用间隙锁,如果其他事务插入了empid大于100的记录,那么本事务如果再次执行上述操作,就会发生幻读。另一方面,是为了满足恢复和复制的需要。

###恢复和复制的需要,对Innodb锁进制的影响###
MySql通过BINLOG录执行成功的insert、update、delete等更新操作的数据的sql语句,并由此实现mysql数据库的恢复和主从复制。Mysql的恢复机制有以下特点:

- mysql的恢复是sql语句级的,也就是重新执行BINLOG中的sql语句,而oracle是基于数据库文件块的。
- mysql的Binlog是按照事务提交的先后顺序记录的,恢复也是按照这个顺序进行的。

mysql的恢复机制要求,在1个事务未提交前,其他并发事务不能插入满足其锁定条件的任何记录,也就是不允许出现幻读。
###什么时候使用表锁###
在以下个别特殊事务中,可以考虑使用表级锁：

- 事务需要更新大部分或全部数据,表又比较大。
- 事务涉及多个表,比较复杂,很可能引起死锁,造成大量事务回滚。

在InnodB下,使用表锁需要注意以下2点:

- 使用LOCKTABLES虽然可以给InnodB加表级锁,但是表锁不是由InnodB存储引擎层管理的,而是由上1层Mysql Server负责的,仅当autocommit=0，`innodb_table_locks`=1时,Innodb层才知道Mysql加的表锁,Mysql Server才会感知InnodB加的行锁。
- 在用LOCKTABLES对Innodb表加锁要注意,要将autocommit设为0,否则Mysql不会给表加锁。事务结束前,不要用unlock tables释放表锁,因为unlock table会隐含地提交事务。

###关于死锁###
2个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。  
发生死锁后,Innodb一般会自动检测到,并使1个事务释放锁并回退,另1个事务获得锁,继续完成事务。但在涉及外部锁或涉及表锁的情况下,Innodb并不能完全自动检测到死锁,者需要通过设置锁等待超时参数`innodb_lock_wait_timeout`来解决。  

1. 在应用中,如果不同的程序会并发存取多个表,应尽量约定以相同的顺序来访问表,这样可以大大降低产生死锁的机会。
2. 在程序以批量方式处理数据的时候,如果事先对数据排序,保证每个线程按固定的顺序来处理记录,也可以大大降低出现死锁的可能。
3. 在事务中,如果要更新记录,应该之将诶申请足够级别的锁,即排他锁,而不是先申请共享锁,更新时再申请排他锁。因为当用户申请排他锁时,其他事务可能又已经获得了相同记录的共享锁,从而造成锁冲突,甚至死锁。

如果出现死锁,可以用`show innodb status`命令来确定最后1个死锁产生的原因。返回结果中包括死锁相关事务的详细信息,据此可以分析死锁产生的原因和改进措施。
