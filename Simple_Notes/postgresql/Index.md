索引.md
<h2>介绍</h2>
假设有像下面这样一个表：

```
CREATE TABLE test1 (
    id integer,
    content varchar
);
```

并且进行大量的类似下面这样的语句进行查询：

```
SELECT content FROM test1 WHERE id = constant;
```

通常，数据库系统不得不一行一行地扫描整个test1表以寻找所有匹配的记录。 如果在test1里面有许多行，但是只返回少数几行(可能是零行或一行)， 那么上面这个方法可就很差劲了。  
如果我们让数据库系统在 id列上维护一个索引用于定位匹配的行。 这样，数据库系统只需要在搜索树中走少数的几层就可以找到匹配行。

在大多数非小说的书籍里面都使用了类似这样的方法： 在书的背后收集着读者会经常查找的术语和概念的索引，并按照字母顺序排列。  
有兴趣的读者可以快速地扫描该索引并且切换到合适的页，因此不用阅读整本书就能查找到感兴趣的位置。  
作者的任务之一就是预计哪些项是读者最需要查找的东西，与之类似，预计哪些索引可以带来便利也是数据库程序员的任务。

下面的命令可以用于在id列上创建前面讨论过的索引：

```
CREATE INDEX test1_id_index ON test1 (id);
```

索引名字`test1_id_index`可以自由选择，但是应该选那些稍后可以让你回忆起索引含义的名字。

要删除一个索引，使用DROP INDEX命令。可以在任何时候向表里增加索引或者从表中删除索引。

一旦你创建了索引，那么就不需要更多干涉了：  
当该表被修改后，系统会自动更新索引，并且当对表进行查询时，如果系统认为使用索引比进行顺序的表扫描更有效时，系统会选择使用索引进行查询。  
不过你可能必须经常性地运行ANALYZE命令以更新统计信息，好让查询规划器能够做出有训练有素的判断。  
参见Chapter 14获取关于如何获知是否使用了索引的信息，以及在什么时候、什么原因下规划器会决定不使用索引。

索引对带搜索条件的UPDATE和DELETE命令也有好处。 索引更可以用于表链接查询。因此，如果你定义了索引的列是链接条件的一部分，那么它可以显著提高链接的查询速度。

在一个巨大的表上创建索引可能会消耗大量的时间。缺省时，PostgreSQL允许在创建索引的同时读取表(SELECT)， 但是写入表(INSERT, UPDATE, DELETE)的动作将被阻塞到索引创建完毕。  
在生产环境下这种阻塞通常是不可接受的， 因此也允许在创建索引的同时写入表，但是有一些警告需要注意，更多信息参见Building Indexes Concurrently。

创建索引之后，它必须和表保持同步。这些操作增加了数据操作的负荷。因此我们应该把那些非关键或者根本用不上的索引删除掉。
<h2>索引类型</h2>
PostgreSQL提供了好几种索引类型：B-tree, Hash, GiST, GIN 。每种索引类型都比较适合某些特定的查询类型，因为它们用了不同的算法。 缺省时，CREATE INDEX命令将创建一个B-tree索引，它适合大多数情况。

 B-tree索引适合处理那些能够按顺序存储的数据之上的等于和范围查询。特别是在一个建立了索引的字段涉及到使用：

<pre>
<
<=
=
>=
>
</pre>

操作符之一进行比较的时候，PostgreSQL的查询规划器都会考虑使用B-tree索引。  
等效于这些操作符组合的构造，比如BETWEEN和IN可以用B-tree索引实现。同时，索引列上的IS NULL或者IS NOT NULL条件也可以用B-tree索引实现。  

仅当模式是一个常量，并且锚定在字符串开头的时候，优化器才会把B-tree索引用于模式匹配操作符LIKE和~， 比如：col LIKE 'foo%'或col ~ '^foo' ，但是 col LIKE '%bar'就不行。  
同时，如果你的服务器未使用C区域设置， 那么你需要用一个特殊的操作符类创建索引来支持模式匹配查询上的索引。参阅Section 11.9。还有可能将B-tree索引用于ILIKE和~*， 但是仅当模式以非字母字符(不受大小写影响的字符)开头才可以。

Hash索引只能处理简单的等于比较。 当一个索引了的列涉及到使用=操作符进行比较的时候，查询规划器会考虑使用Hash索引。 下面的命令用于创建Hash索引：

```
CREATE INDEX name ON table USING hash (column);
```

Caution
Hash索引操作目前没有记录WAL日志，因此如果发生了数据库崩溃，我们可能需要用REINDEX重建Hash索引。 他们也不会通过流或基于文件复制而被复制。

GiST索引不是单独一种索引类型，而是一种架构，可以在这种架构上实现很多不同的索引策略。 因此，可以使用GiST索引的特定操作符类型高度依赖于索引策略(操作符类)。 作为示例，PostgreSQL的标准发布中包含用于二维几何数据类型的 GiST 操作符类，它支持：

<pre>
<<
&<
&>
>>
<<|
&<|
|&>
|>>
@>
<@
~=
&&
</pre>

这些操作符的含义参见Section 9.11。许多其它GiST操作符类位于contrib中，或者是单独的项目，更多信息参见Chapter 52。
GIN索引是反转索引，它可以处理包含多个键的值(比如数组)。 与GiST类似，GIN支持用户定义的索引策略，可以使用GIN索引的特定操作符类型根据索引策略的不同而不同。 作为示例，PostgreSQL的标准发布中包含用于一维数组的GIN操作符类，它支持：

<pre>
<@
@>
=
&&
</pre>

这些操作符的含义参见Section 9.17。 许多其它GIN操作符类位于contrib中，或者是单独的项目。
<h2>多字段索引</h2>
一个索引可以定义在表中多个字段上。比如，如果有以下格式的表：

```
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
```

显而易见，/dev目录被保存在一个数据库里，并且你经常做下面这样的查询：

```
SELECT name FROM test2 WHERE major = constant AND minor = constant;
```

那么在字段major和minor上联合定义一个索引是比较合适的做法，也就是：

```
CREATE INDEX test2_mm_idx ON test2 (major, minor);
```

目前，只有B-tree，GiST和GIN支持多字段索引。 最多可以声明32个字段(这个限制可以在编译PostgreSQL时改变， 见pg_config_manual.h文件)。

一个多字段的B-tree索引可以用在包含索引字段子集的查询条件里，不过，如果在前导字段(最左边)上有约束条件，那么效率最高。  
准确的规则是前导字段上的等于约束，加上第一个没有等于约束的非等于约束字段，将用于限制所扫描的索引范围。  
将检查这两个字段右边字段上的索引以减少对表的访问，但是并不减少需要扫描的索引。
比如，假如我们有一个在(a, b, c)上的索引，查询条件是WHERE a = 5 AND b >= 42 AND c < 77， 那么索引就需要先扫描所有a = 5且b = 42 ，直到所有a = 5的记录扫描完毕。那些 c >= 77 的索引条目将被忽略，但是他们仍然会被扫描。  
这个索引原则上仍然会被用于那些在b和/或c上有约束，但是在a上没有约束的查询—，但是就必须扫描整个索引了。  
因此，在大多数这种情况下，优化器会选择顺序扫描表，而不使用索引。

一个多字段的GiST索引只能用于那些在前导字段上有查询条件的查询中。 附加字段上的条件会限制索引返回的条目，但是第一个字段上的条件是决定需要扫描多少索引内容的最重要的字段。 如果在第一个字段上只有很少的一些唯一的数值，那么GiST就相对来说不那么高效了，即使在附加字段上有许多独立的数值也如此。

多字段GIN索引可用于涉及任何索引列子集的查询条件。与B-tree或GIST不同，不管使用的索引列的查询条件，索引搜索的有效性是相同的。

当然，每个字段都必须和适合该索引类型的操作符一起使用；包含其它操作符的子句将不会被考虑。

使用多字段索引应该谨慎。 在大多数情况下，在单字段上的索引就足够了，并且还节约时间和空间。 除非表的使用模式非常固定，否则超过三个字段的索引几乎没什么用处。 见Section 11.5获取有关不同索引设置的优缺点的讨论。

<h2>索引与ORDER BY</h2>
除了简单地找到被查询返回的行， 索引也能够在一个特定的排序中提供它们。 这使得查询的ORDER BY规范在没有一个单独的排序步骤下能够实现。 目前PostgreSQL支持的索引类型中，只有B-tree 能产生排序输出— 其他索引类型返回 未指定的匹配行，依赖于实现秩序。

规划器在通过扫描匹配规范的可用索引，或对表进行物理顺序扫描，做一个明确的 排序时会考虑满足ORDER BY规范。  
当对表进行的查询需要大范围扫描时，一个明确的排序很可能比使用索引要快。 因为对于顺序访问模式，它需要 减少磁盘I/O。当只有几行需要获取时，索引更有用。  
一个重要的特殊情况是ORDER BY连接 LIMIT n:明确的排序将处理 所有的数据，以确定第一个n行，但如果有一个索引匹配ORDER BY， 第一个n行可以直接检索，没有扫描其余的。

缺省情况下，B-tree索引存储升序存放他们的记录（空记录在最前面）。 这意味着，向前索引扫描在列x产生满足ORDER BY x的输出（或更冗长，ORDER BY x ASC NULLS LAST）。  
索引也可以向后扫描，产生满足ORDER BY x DESC产生输出（或更冗长，ORDER BY x DESC NULLS FIRST,因为 NULLS FIRST是 ORDER BY DESC的缺省）。

当创建索引时，你可以通过选项ASC, DESC, NULLS FIRST, 和（或者）NULLS LAST调整B-tree索引的排序，比如：

```
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
不论是对ORDER BY x ASC NULLS FIRST还是ORDER BY x DESC NULLS
```

最后，索引可以以升序存储空值，这取决于在哪个方向上扫描。

你可能会问，当两个选项一起向后扫描的可能性将涵盖ORDER BY的所有变化时，为什么还要提供四个选项。  
在单列索引中，选项确实是多余的，但在多字段索引中却是有用。 思考一个关于(x, y)的两字段索引：如果我们向前扫描，这可以 满足ORDER BY x, y，或如果我们向后扫描，可以满足 ORDER BY x DESC, y DESC。  
但可能应用程序经常需要使用 ORDER BY x ASC, y DESC。没有办法得到 一个普通索引的排序，但如果该指数被定义为(x ASC, y DESC)或者(x DESC, y ASC)，那么就可能得到该排序。

显然，非缺省排序的索引是一个相当专业的功能，但有时却可以提高某些查询的速度。 是否值得维护这样一个索引取决于你经常使用需要一个特殊排序的查询。
<h2>组合多个索引</h2>
一个单独的索引扫描只能用于这样的条件子句：使用被索引字段和索引操作符类中操作符，并且这些条件以 AND连接。 假设在(a, b)上有一个索引，那么类似 WHERE a = 5 AND b = 6 的条件可以使用索引， 但是像WHERE a = 5 OR b = 6的条件就不能直接使用索引。

幸运的是，PostgreSQL能够组合多个索引(包括同一索引的多次使用)来处理单个索引扫描不能实现的情况。  
系统可以在多个索引扫描之间组成AND和OR条件。 比如，一个类似WHERE x = 42 OR x = 47 OR x = 53 OR x = 99这样的查询可以分解成四个在x上的独立扫描， 每个扫描使用一个条件，最后将这些扫描的结果OR在一起，生成最终结果。
另外一个例子是，如果我们在x 和y上有独立的索引，一个类似WHERE x = 5 AND y = 6这样的查询可以分解为几个使用独立索引的子句， 然后把这几个结果AND在一起，生成最终结果。

为了组合多个索引，系统扫描每个需要的索引，然后在内存里组织一个位图，它给出索引扫描报告中符合索引条件的表数据行位置。  
然后，根据查询的需要，把这个位图使用AND和OR合并在一起。  
最后，访问实际的表检索并返回数据行。表的数据行是按照物理顺序进行访问的，因为那就是位图的布局；
这就意味着任何原来的索引排序都将消失，而如果查询有一个 ORDER BY子句，那么还需要一个额外的排序步骤。 因为这个原因，以及每个额外的索引扫描都增加了额外的时间，规划器有时候会选择使用简单的索引扫描，即使有多个索引可用也如此。

在所有最简单的应用里，可能有多种索引组合都是有用的，数据库开发人员必须在使用哪个索引之间作出平衡。  
有时候多字段索引是最好的，但有时候创建一个独立索引并依靠索引组合是最好的。
比如，假如你的查询有时候只涉及字段x，有时候只涉及字段y，有时候两个字段都涉及， 那么你可能会选择在 x和y上创建两个独立的索引，然后依靠索引组合来处理同时使用两个字段的查询。
你也可以在(x, y)上创建一个多字段索引，这样索引通常会比比索引组合更高效， 但是，正如我们在Section 11.3里面讨论的，它对那些只包含y的查询几乎没有用，因此它不能是唯一一个索引。  
一个多字段索引和y上的独立索引可能会更好。因为对那些只涉及x的查询，可以使用多字段索引，尽管它会更大， 会比只在x上的索引更慢。  
最后一个选择是创建三个索引，但是这种方法只有在表的更新远比查询少得多，并且所有三种查询都很普遍的情况下才是合理的。  
如果其中一种查询比其它的少很多，那么你可能更愿意仅仅创建两种匹配更常见查询的索引。
<h2>唯一索引</h2>
索引还可以用于强制规定一个字段数值的唯一性，或者是多个字段组合值的唯一性。

```
CREATE UNIQUE INDEX name ON table (column [, ...]);
```

目前，只有B-tree索引可以声明为唯一。

如果索引声明为唯一的，那么就不允许出现多个索引值相同的行。NULL值被认为互不相等。 一个多字段唯一索引认为只有多行数据里所有被索引字段都相同才是相同的，这种数据才被拒。

如果一个表声明了唯一约束或者主键， 那么PostgreSQL自动在组成主键或唯一约束的字段上创建唯一索引(可能是多字段索引)，以强制规定这些约束。

Note: 一个给表增加唯一约束更好的方法是ALTER TABLE ... ADD CONSTRAINT。 用索引强制唯一约束应该认为是一个实现细节，而不应该直接访问。 不过，我们应该知道没有必要在唯一字段上建立索引，那样做只会重复建立自动创建的索引。

<h2>表达式上的索引</h2>
索引并非一定要是一个底层表的字段， 还可以是一个函数或者从一个或多个字段计算出来的标量表达式。 这个特性对于快速访问那些基于计算结果的表非常有用。

比如，做大小写无关比较的常用方法是使用lower函数：

```
SELECT * FROM test1 WHERE lower(col1) = 'value';
```

如果已经在lower(col1)函数的结果上定义了索引，那么这个查询可以使用索引：

```
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
```

如果我们把这个索引声明为UNIQUE， 那么它会禁止创建那种col1数值只是大小写有别或完全相同的数据行。 因此，在表达式上的索引可以用于强制那些无法定义为简单唯一约束的约束。

另外一个例子是，如果我们经常使用下面这样的查询：

```
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
```

那么我们就值得创建下面这样的索引：

```
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
```

CREATE INDEX命令的语法通常要求在索引表达式周围书写圆括弧， 就像我们在第二个例子里显示的那样。如果表达式只是一个函数调用， 那么可以省略，就像我们在第一个例子里显示的那样。

从维护角度来看，索引表达式相对费劲一些，因为在插入数据行或者更新数据行的时候，都必须为每一行计算生成的表达式。 不过，索引表达式不是在索引查找的时候进行计算的，因为它们已经存储在索引里了。 在上面的两个例子里，系统都把查询看做只是WHERE indexedcolumn = 'constant'，所以搜索的速度等效于任何其它简单的索引查询。 因此，表达式上的索引在检索速度比插入和更新速度更重要的场合下是有用的。
<h2>部分索引</h2>
部分索引是建立在一个表的子集上的索引； 该子集是由一个条件表达式定义的(叫做部分索引的谓词)。 该索引只包含表中那些满足这个谓词的行。部分索引是一个特殊的特性，但是在某些场合很有用。

部分索引的主要动机是为了避免对普通数值(大量重复的数值)建立索引。因为在普通数值上的查询就算使用索引也没什么好处， 那么还不如从索引中剔除这些大量重复的行。这样可以减小索引尺寸，提高那些真正使用索引的查询的速度。 同时它也能提高更新操作的速度，因为不是所有情况都需要更新索引。Example 11-1显示了一个潜在的这方面应用的例子。

Example 11-1. 设置一个部分索引以排除普通数值

假设你在数据库中存储web服务器的访问日志。 大多数访问是从你的组织内部的IP地址范围发起的， 但也有一小部分来自其它地方(比如那些通过拨号进行连接的雇员)。 如果你主要搜索来自外部访问的IP，那么你就不需要对组织子网的IP范围进行索引。

假设表像下面这样：

```
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
```

要创建符合例子的索引，使用像下面这样的命令：

```
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip > inet '192.168.100.0' AND
           client_ip < inet '192.168.100.255');
```

一个可以使用这个索引的典型查询如下：

```
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
```

一个不能使用这个索引的查询是：

```
SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';
```

我们通过观察可以看出，这种类型的部分索引要求普通数值是可以预计的。所以部分指标最适合用于 不改变的数据分布。索引可以重新重建偶尔调整新的数据分布，但是这会增加维护工作。

另外一个用途在Example 11-2里显示， 它把不感兴趣的数值排除在索引之外。这个结果有与上面列出的同样的优点， 但是它完全拒绝了通过索引访问"不感兴趣"的数值， 即使索引扫描可能对那些数据也有利。显然，为这种情况设置部分索引需要非常仔细并且需要大量试验。

Example 11-2. 设置一个部分索引以排除不感兴趣的数值

如果你有一个表，包含已付款和未付款的定单， 而未付款的定单只占总表的一小部分并且是经常使用的部分， 那么你可以通过只在未付款定单上创建一个索引来改善性能。 创建索引的命令看起来会像这样：

```
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
```

可能用到这个索引的查询看起来像：

```
SELECT * FROM orders WHERE billed is not true AND order_nr < 10000;
```

不过，该索引也可以用于那些完全不涉及order_nr查询，比如：

```
SELECT * FROM orders WHERE billed is not true AND amount > 5000.00;
```

这个查询不像在amount字段上的部分索引那么有效， 因为系统必须扫描整个索引。但是，如果未付款的定单相对较少， 那么用这个部分索引找出未付款的定单将会更快些。

请注意下面这个查询无法使用这个索引：

```
SELECT * FROM orders WHERE order_nr = 3501;
```

定单3501可能是已付款也可能是未付款。

Example 11-2还说明了建了索引的字段和谓词中的字段不必相配。 PostgreSQL支持带任意谓词的部分索引，只要只涉及被索引表的字段就行。 不过，我们要记住的是谓词必须和那些希望从该索引中获益的查询条件相匹配。  
准确说，只有在系统能够识别出该查询的WHERE条件在数学上蕴涵了该索引的谓词时，这个部分索引才能用于该查询。  
PostgreSQL还没有智能到可以完全识别那些形式不同但数学上相等的谓词。 做到这样不仅非常困难，而且在实际使用中也可能非常慢。  
系统可以识别简单的不相等蕴涵，比如"x < 1"蕴涵"x < 2"； 否则，谓词条件必须准确匹配查询的 WHERE 条件，不然系统将无法识别该索引是可用的。  
匹配发生在查询规划期间，而不是运行期间。因此，参数化的查询子句必定不会使用部分索引。  
例如，一个预先写好的、带有参数的查询可能指定了"x < ?"，它不可能对所有可能的参数值都蕴涵"x < 2"。

部分索引的第三种用途是禁止在查询中使用索引。 如Example 11-3所示，这里的概念是在表的子集里创建唯一索引。 这样就强制在满足谓词的行中保持唯一性，而并不约束那些不需要唯一的行。

Example 11-3. 设置一个部分唯一索引

假设我们有一个记录测试输出的表。 我们希望确保在每个目标和课题的组合中只有一个"成功"记录， 但是可以有任意数量的"不成功"记录。下面是实现方法：

```
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
```

如果只有少数成功测试而有很多不成功测试，那么这是一种非常有效的实现方法。

最后，部分索引也可以用于取代系统选择的查询规划。 可能会出现这样的情况：如果数据集的分布是比较特定的形状， 那么会导致系统在不该使用索引的时候使用它。在这种情况下， 我们可以把索引设置为在违反规律的查询中不可用。 通常PostgreSQL对索引的使用会做出合理的选择(比如，它在检索普通数值的时候避免使用它， 因此前面的例子实际上只是节约了索引的尺寸，它并不要求避免索引的使用)，但是如果出现了错误的规划选择那么请提交一个臭虫报告。

请记住一件事：设置一个部分索引表示你至少和查询规划器知道的一样多， 特别是你知道什么场合下索引是有效的。要形成这些知识要求你经验丰富并且理解PostgreSQL的索引是如何运作的。 在大多数情况下，部分索引对普通索引的优势并不太明显。

<h2>操作类和操作簇</h2>
定义索引的同时可以为索引的每个字段声明一个操作符类operator class。

```
CREATE INDEX name ON table (column opclass [sort options] [, ...]);
```

这个操作符类指明该索引用于该字段时要使用的操作符。 例如，一个在int4上的B-tree索引将使用int4_ops类；这个操作符类包括用于int4的比较函数。 实际上，字段类型的缺省操作符通常就足够了。拥有操作符类的主要原因是：对于某些数据类型，可能存在多个有意义的索引行为。 例如，我们可能想排序两个复数，既可能通过绝对值，也可能通过实部。我们可以通过为该数据类型定义两个操作符类，然后在建立索引时选择合适的那个。 操作符类决定基本的排序顺序（通过添加排序选项ASC/DESC和（或者） NULLS FIRST/NULLS LAST然后进行修改）

除了缺省的以外，还有一些有内置的操作符类：

text_pattern_ops,varchar_pattern_ops, 和bpchar_pattern_ops操作符类分别支持在text, varchar,和char类型上的B-tree索引。  
他们与缺省操作符类的区别在于数值是严格地逐个字节比较的，而不是根据区域相关的集合规则进行比较。
这样，如果数据库不使用标准的"C"区域设置， 那么这些操作符类适用于那些涉及模式匹配表达式(LIKE或者POSIX正则表达式)的查询。 举一个例子，你可以像下面这样对一个varchar字段进行索引：

```
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
```

请注意，相比较使用索引而言，如果你希望包含普通<,<=, >, 或>=， 那么你还应该创建一个使用缺省操作符类的索引。这样的查询不能使用xxx_pattern_ops操作符类。 （然而，普通等价的比较，可以使用这些 操作符类。）允许在同一个字段上创建多个使用不同操作符类的索引。 如果你确实使用了标准的"C"区域设置，那么你就不需要xxx_pattern_ops操作符类， 因为使用缺省操作符类的索引可以用于C区域里面的模式匹配查询。

下面的查询显示所有已定义的操作符类：

```
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
```

一个操作符类实际上是一个称为 operator family的更大结构的子集。当几个数据类型的作用类似时，可以定义cross-data-type类型操作符并且与索引一起使用。 要做到这一点，每个类型的操作符类必须分成相同的操作符组。cross-type型的操作符是组成员，但不与组内的任何单个类连接。

这个查询显示所有已定义的操作符组和所有包含在每个组中的所有操作符：

```
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
```

<h2>检查索引的使用</h2>
尽管在PostgreSQL里的索引并不需要维护或调节， 但是检查一下哪些索引在实际查询中被使用了仍然非常重要。 检查索引的使用是通过EXPLAIN命令进行的； 为此目的做的应用在Section 14.1里有演示。 我们也可以在一个运行的服务器上收集有关索引使用的统计信息， 就像Section 27.2里描述的那样。

对判断需要设置哪些索引，进行归纳，制定一个通用过程是很难的。 在前面的章节中已经列出了许多典型的例子。在大多数情况下我们都需要许多试验。 本节的剩余部分就是给出一些这方面的窍门:

总是先运行ANALYZE命令收集关于表中数值分布的统计信息。 猜测一个查询返回的行数需要这个信息，而规划器需要这个行数以便给每个可能的查询规划赋予真实开销值。 如果缺乏任何真实的统计信息，那么就会假设一些缺省数值，那肯定是不准确的。 因此，如果还没有运行ANALYZE就检查一个应用的索引使用状况，那实际上就是一次失败的检查。

使用真实的数据做实验。用测试数据设置索引将告诉你在测试数据中需要什么索引，而不是在真实数据中。

最要命的是用很小的数据集。如果从100000行中选1000行是使用索引的好时机， 那么从100行中选1行很难说也需要索引，因为100行很可能是装在一个磁盘页里面的，因此没有任何查询规划能比通过顺序访问抓取一个磁盘页面更有效。

做测试数据的时候也要小心，如果应用还不能在生产环境中使用，那么这也是不可避免的。那些非常相似的数据、完全随机的数据、 或者按照排序顺序插入的数据会令统计信息偏离实际数据的特征。

如果索引没有得到使用，那么在测试中强制它的使用也许有些价值。 有一些运行时参数可以关闭各种各样的查询规划(在Section 18.6.1中描述)。 比如，关闭顺序扫描(enable_seqscan)和嵌套循环连接(enable_nestloop)将强迫系统使用不同的规划。 如果系统仍然选择顺序扫描或者嵌套循环连接，那么在为何索引没有得到使用的问题中可能有更基本的问题， 比如，查询条件和索引不匹配等(前面的章节中介绍了什么样的查询可以使用什么样的索引)。

如果强制索引用法确实使用了索引，那么就有两种可能： 要么是系统选择是正确的：使用索引实际上并不合适， 要么是查询计划的开销计算并不反映现实情况。 这样你就应该对使用和不使用索引的查询进行计时。 这个时候EXPLAIN ANALYZE命令就很有用了。

如果实际情况说明开销计算是错误的，那么仍然有两种可能。 总开销是从每行的每个规划节点乘以每个规划节点的选择性估计的开销计算出来的。 规划节点的开销可以用一些运行时参数进行调节(在Section 18.6.2中描述)。不准确的选择性估计是因为统计信息不够充分。 我们可以通过调节统计收集参数(参阅ALTER TABLE)提高选择性估计的精度。

如果你没能通过将开销调整得更准确而实现索引的使用，那么你可能不得不求助于明确地强制索引使用。并且与PostgreSQL开发人员联系并讨论你的情况。
