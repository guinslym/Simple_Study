管理数据库.md
每个正在运行的PostgreSQL服务器实例都管理着一个或多个数据库。因此，在组织SQL对象("数据库对象")的层次中，数据库位于最顶层。 本章描述数据库的属性，以及如何创建、管理、删除它们。
##概述##
数据库是一些SQL对象("数据库对象")的集合；通常每个数据库对象(表、函数等)属于并且只属于一个数据库。不过有几个系统表(比如pg_database)属于整个集群 并且可以在集群之内的每个数据库里访问。更准确地说，一个数据库是一个模式的集合， 而模式包含表、函数等等。因此完整的层次是这样的：服务器→数据库→模式→表(或者其它的对象类型，比如函数)。

在与数据库服务器连接的时候，应用应该在它的连接请求里指明它想连接的数据库名称。不允许在一次连接里访问多个数据库(不过没有限制一个应用可以建立的连接数量)。  
数据库是物理上相互隔离的，对它们的访问控制是在连接层次进行的。如果一个PostgreSQL服务器实例用于承载那些应该分隔并且相互之间并不知晓的用户 和项目，那么我们建议把它们放在不同的数据库里。如果项目或者用户是相互关联的， 并且可以相互使用对方的资源，那么应该把它们放在同一个数据库里，但可能在不同的模式中。模式只是一个纯粹的逻辑结构，谁能访问某个模式由权限系统控制。

数据库是使用`CREATE DATABASE`命令创建的,用`DROP DATABASE`command命令删除。要查看现有数据库的集合，可以检查系统表pg_database，比如

```
SELECT datname FROM pg_database;
```

psql程序的\l命令和-l命令行选项也可以用来列出现存的数据库。

Note: SQL标准把数据库称作"目录"(catalog)，不过这两个东西实际上没有什么区别。
##创建1个数据库##
为了创建和删除数据库，必须先运行PostgreSQL服务器。

数据库是用SQL命令CREATE DATABASE创建的：

```
CREATE DATABASE name;
```

这里的name遵循SQL标识符的一般规则。当前角色自动成为此新数据库的所有者。同时，以后删除这个数据库也是这个用户的特权(同时还会删除其中的所有对象，即使那些对象有不同的所有者也这样)。

创建数据库是一个有限制的操作。因为你需要与数据库服务器连接才能执行CREATE DATABASE命令， 那么还有一个问题是第一个数据库是怎样创建的?  
第一个数据库总是由initdb命令在初始化数据存储区的时候创建的。这个数据库叫postgres而且不能被删除。 因此要创建第一个"真正"的数据库时你可以与postgres连接。

initdb也会同时创建名为template1,的数据库。在创建一个新的数据库时，实际上就是克隆(复制)了数据库。这就意味着你对template1所做的任 何修改都会在所有随后创建的数据库中体现出来。因此把模板数据库用于实际工作中并不明智，但是如果有意地使用这个特性，那它可以带来许多方便(比如增加用户定义函数等等)。

另外，为了方便，你还可以用程序来创建新数据库：

```
createdb dbname
```

createdb和postgres数据库连接并执行CREATE DATABASE命令。 createdb的手册页包含使用它的细节。尤其是不带任何参数调用createdb时将创建与当前用户名同名的数据库。

Note: Chapter 19包含有关如何限制哪些用户可以连接某个特定数据库的信息。

有时候你需要为其它人创建一个数据库，并且使其成为新数据库的所有者，这样他就可以自己配置和管理这个数据库。要实现这个目标，使用下列命令中的一条：

```
CREATE DATABASE dbname OWNER rolename;
或
createdb -O rolename dbname
```

前者用于SQL环境，后者用于命令行。只有数据库的超级用户才能为其它用户创建数据库。
##临时库##
CREATE DATABASE实际上是通过拷贝一个现有的数据库进行工作的。缺省时，它拷贝名为template1的标准系统数据库。所以该数据库是创建新数据库的"模板"。   
如果你给template1数据库增加对象，这些对象将被拷贝到随后用户创建的数据库中。 这样的行为允许节点对数据库中的标准套件进行修改。比如，如果你把过程语言PL/Perl安装到 template1里，那么你在创建用户数据库的时候它们就会自动可得，而不需要额外的动作。

系统里还有名为template0的第二个标准系统数据库，这个数据库包含和template1初始时一样的数据内容，也就是说， 只包含标准的PostgreSQL对象。在initdb之后，我们不应该对template0做任何修改。  
通过告诉CREATE DATABASE使用template0而不是template1进行拷贝，你可以创建一个"纯净"的用户数据库，它不会包含任何 template1里所特有的东西。  
这一点在恢复pg_dump转储的时候是非常方便的：转储脚本应该在一个纯净的数据库中恢复以确保我们正确创建了被转储出的数据库内容， 而不和任何现在可能已经存在于template1中的附加物相冲突。

另一个复制template0中而不是template1的常见原因是，可以在复制template0时声明新的编码和区域设置，而如果复制template1时， 必须使用与它相同的设置。这是因为的template1可能包含特定编码或区域特定的数据，而template0中不需要。

要通过拷贝 template0 的方法创建一个数据库，可使用下列方法之一：

```
CREATE DATABASE dbname TEMPLATE template0;
createdb -T template0 dbname
```

前者用于SQL环境，后者用于shell环境。

我们可以创建额外的模板数据库，而且实际上我们可以在一个集群中通过将CREATE DATABASE的模板声明为相应的数据库名拷贝任何数据库。 不过，我们必需明白，这个功能并非一般性的"COPY DATABASE"工具。实际上，在拷贝操作的过程中，源数据库必需是空闲状态(没有正在处理的数据修改事务)。如果在 CREATEDATABASE 开始的时候存在其它连接，那么操作将会失败，否则在CREATE DATABASE的执行过程中新连接都将被锁定，直到拷贝完成。

在pg_database里有两个有用的标志可以用于每个数据库：datistemplate和 datallowconn 字段。datistemplate 表示该数据库是可以用作 CREATE DATABASE时的模板。如果设置了这个标志，那么该数据库可以由任何有 CREATEDB权限的用户克隆；如果没有设置，那么只有超级用户和该数据库的所有者可以克隆它。如果 datallowconn 为假，那么将不允许与该数据库发生任何新的连接(不过现有的会话不会因为把该标志设置为假而被杀死)。template0数据库通常被标记为datallowconn= false以避免对它的修改。template0和template1都应该总是标记为datistemplate=true 。

Note: 除了template1是CREATE DATABASE的缺省源数据库名之外，template1和template0没有任何特殊的状态。比如，我们可以删除template1然后从template0 中创建它而不会有任何不良效果。如果我们不小心在template1 里加了一堆垃圾，那么我们就会建议做这样的操作。template1必须得是 pg_database.datistemplate = false才能被删除。

在初始化数据库集群的时候，也会创建postgres数据库。这个数据库用于做为用户和应用连接的缺省数据库。它只是template1的一个简单拷贝，需要的时候可以删除或者重建。
##删除数据库##
数据库是用 DROP DATABASE命令删除的：

```
DROP DATABASE name;
```

只有数据库的所有者或者超级用户才可以删除数据库。删除数据库会删除数据库中包括的所有对象。数据库的删除是不可恢复的。

你不能在与目标库连接的时候执行DROP DATABASE命令。不过，你可以和其它数据库连接，包括template1数据库。template1也是你删除集群中最后一个库的唯一方法。

为了方便，有一个在 shell 上运行的删除数据库的dropdb:命令：

```
dropdb dbname
```

(它和 createdb不一样，没有缺省删除与当前用户名相同的数据库.)
##表空间##
PostgreSQL里的表空间允许数据库管理员在文件系统里定义那些代表数据库对象的文件存放位置。一旦创建了表空间，那么就可以在创建数据库对象的时候引用它。

通过使用表空间，管理员可以控制一个PostgreSQL安装的磁盘布局。这么做至少有两个用处。首先，如果初始化集群所在的分区或者卷用光了空间， 而又不能逻辑上扩展或者别的什么操作，那么表空间可以在一个不同的分区上创建和使用，直到系统可以重新配置。

第二，表空间允许管理员根据数据库对象的使用模式安排数据位置，从而优化性能。 比如，一个很频繁使用的索引可以放在非常快并且非常可靠的磁盘上，比如一种非常贵的固态设备。 而同时，一个存储归档的数据，很少使用的或者对性能要求不高的表可以存储在一个便宜但比较慢的磁盘系统上。

要定义一个表空间，使用命令，比如：

```
CREATE TABLESPACE fastspace LOCATION '/mnt/sda1/postgresql/data';
```

这个位置必须是一个现有的空目录，并且属于 PostgreSQL 系统用户。 所有随后在该表空间创建的对象都将被存放在这个目录下的文件里。

Note: 当在逻辑文件系统上定义不止一个表空间时，并没有那么多的条件，因为您无法控制逻辑文件系统中的特定文件的位置。 然而，的PostgreSQL不执行任何这样的限制，并且实际上是不直接识别您的文件系统边界，它仅仅只是存储在你定义的目录中。

创建表空间时必须是数据库超级用户，但在创建完之后之后，可以给数据库普通用户授予create的权限(在该表空间上的权限)来使用它。

表、索引和整个数据库都可以放在特定的表空间里。想要这么做的话，在给定表空间上有CREATE权限的用户必须把表空间的名字以一个参数的形式传递给相关的命令。 比如，下面的命令在表空间space1上创建一个表：

```
CREATE TABLE foo(i int) TABLESPACE space1;
```

另外，还可以使用default_tablespace参数：

```
SET default_tablespace = space1;
CREATE TABLE foo(i int);
```

只要default_tablespace被设置为非空字符串，那么它就为没有明确使用TABLESPACE子句的CREATE TABLE和CREATE INDEX命令提供一个隐含的子句。

还有temp_tablespaces参数，决定临时表和索引的位置，以及如用于对大数据进行排序的临时文件。   
这可以是一个表空间名的列表，而不是只有一个，因此，与临时对象有关的负载可以遍及多个表空间。列表中的一个随机成员每次采摘时创建一个临时对象。

与数据库相关联的表空间用来存储该数据库的系统目录表。 此外，如果没有TABLESPACE条款给出，并且`default_tablespace`或者`temp_tablespaces`(如适用)没有进行其他的声明时，它还是在该数据库中创建的表，索引，临时文件的默认表空间。如果没有创建数据库时没有声明表空间，它会使用与模板数据库相同的表空间。

当初始化数据库集群时，自动创建两个表空间：`pg_global`(用于存储共享系统目录表)和`pg_default`表空间，这个表空间是表是默认的表空间 template1和template0数据库的默认表空间，因此，如果CREATE DATABASE时没有 通过TABLESPACE字句声明表空间，那么，pg_default表空间会是作为该数据库的默认表空间。

表空间一旦被创建，那么它就可以被任何数据库使用，并提供给发出请求的用户足够的权限。这也意味着，一个表空间 只有在表空间中所有数据库下所有对象都被删除掉之后才可以被删掉。

要删除一个空的表空间，使用 DROP TABLESPACE 命令。

通过查看pg_tablespace系统表，可以获取已有的表空间的属性，比如

```
SELECT spcname FROM pg_tablespace;
```

psql程序的`\db`命令也可以用于列出现有表空间。

PostgreSQL通过使用符号连接来简化表空间的实施，这就意味着表空间只能在支持符号连接的系统上使用。

`$PGDATA/pg_tblspc`目录下包含指向集群里定义的每个非内置表空间的符号连接。尽管我们不建议，但是我们还是可能通过手工重定义这些连接来调整表空间的布局。  
两个警告：在服务器运行时，以及重启服务器之后，更新`pg_tablespace`表的显示新位置时不能这么做。否则`pg_dump`将继续显示旧的表空间位置。