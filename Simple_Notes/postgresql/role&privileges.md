数据库角色和权限.md
根据角色自身的设置不同，一个角色可以看做是一个 数据库用户，或者一组数据库用户。角色可以拥有数据库对象(比如表)以及 可以把这些对象上的权限赋予其它角色，以控制谁拥有访问哪些对象的权限。 另外，我们也可以把一个角色的成员权限赋予其它角色，这样就允许成员角色使用它被赋予其他成员权限的角色的权限。    
角色的概念替换了"用户"和"组"。在PostgreSQL版本8.1之前，用户和组是独立类型的记录，但现在它们只是角色。任何角色都可以是一个用户、一个组、或者两者。  
本章描述如何创建和管理角色，以及介绍权限系统。  
##数据库角色##
数据库角色从概念上与操作系统用户是完全无关的。在实际使用中 把它们对应起来可能比较方便，但这不是必须的。数据库角色在整个数据库集群中是全局的(而不是每个库不同)。要创建一个角色，使用SQL命令CREATE ROLE执行：

```
CREATE ROLE name;
```

name遵循SQL标识的规则：要么完全没有特殊字符，要么用双引号包围(实际上你通常会给命令增加额外的选项，比如LOGIN)。要删除一个现有角色，使用类似的 DROP ROLE命令：

```
DROP ROLE name;
```

为了方便，程序createuser和dropuser提供了对了这些SQL命令的封装。我们可以在shell命令上直接调用它们：

```
createuser name
dropuser name
```

要检查现有角色的集合，可以检查pg_roles系统表，比如：

```
SELECT rolname FROM pg_roles;
```

psql的元命令`\du`也可以用于列出现有角色。
为了能创建初始数据库系统，新建立的数据库总是包含一个预定义的 "超级用户"角色，并且缺省时(除非在运行initdb 时更改过)他将和初始化该数据库集群的用户有相同的名称。通常，这个角色名叫 postgres。为了创建更多角色，你必须首先以这个初始用户角色连接。  

每一个和数据库的连接都必须以一个角色身份进行，这个角色决定在该连接上的初始权限。特定数据库连接的角色名是在初始化连接请求的时候声明的。 比如，psql程序使用-U命令行选项声 明它代表的角色。许多应用以当前操作系统的用户名为缺省角色名(这样的应用包括createuser和psql)。所以，在系统用户和数据库角色之间有某种命名关系会让我们工作方便很多。  

一个客户端连接可以使用的角色集合是由客户认证设置决定的，因此，一个客户端并不局限于以它的操作系统用户同名的角色进行连接，就像你登录系统的 名称不一定要是你的真实姓名一样。因为角色的身份决定了一个连接的权限， 所以在多用户环境里仔细配置这些内容是非常重要的。
##角色属性##
一个数据库角色可以有一系列属性，这些属性定义他的权限，以及与客户认证系统的交互。

###LOGIN属性###
只有具有LOGIN属性的角色才可以用作数据库连接的初始角色名。一个带有LOGIN属性的角色可以认为是和"数据库用户"相同的事物。要创建一个具有登录权限的角色，用下列之一：

```
CREATE ROLE name LOGIN;
CREATE USER name;
```

除了CREATE USER默认赋予LOGIN之外，CREATE USER等价于CREATE ROLE(默认不赋予LOGIN)。可以采用alter role name login来赋予其登陆的权限。

###超级用户###
数据库超级用户超越所有权限检查。这是一个危险的权限，应该小心使用；最好使用非超级用户完成你的大多数工作。要创建数据库超级用户，用`CREATE ROLE name SUPERUSER`命令。你必须用已经是超级用户的角色执行这条命令。

###创建数据库###
角色要想创建数据库，必须明确给出权限(对于超级用户是例外，因为他们超越所有权限检查)。要创建这样的角色， 用`CREATE ROLE name CREATEDB`命令。

###创建角色###
角色要想创建角色，必须明确给出权限(对于超级用户是例外， 因为他们超越所有权限检查)。要创建这样的角色， 用CREATE ROLE name CREATEROLE命令。 一个带有CREATEROLE属性的角色也可以更改和删除其它角色， 以及给其它角色赋予或者撤销成员关系。不过，要创建、更改、删除一个 超级用户角色的成员关系，需要具有超级用户属性；只有CREATEROLE还不够。

###口令###
只有在客户认证方法要求与数据库建立连接必须使用口令的时候，口令才比较重要。password,md5认证方法使用口令。数据库口令与操作系统口令是无关的。 在创建角色的时候可以这样声明一个口令： 

```
CREATE ROLE name PASSWORD string'；
```

一个角色的属性可以在创建后用`ALTER ROLE`修改。

Tip: 创建一个具有CREATEDB和CREATEROLE权限， 但是并非超级用户的角色是一个很好的习惯， 你可以使用这个角色进行所有日常的数据库和角色管理。 这个方法避免了以超级用户操作时，发生误操作导致的严重后果。

一个角色也可以为许多运行时配置设置针对其个人的缺省，比如，如果出于某种原因你想在所有你做的连接中关闭索引扫描(不是个好主意)，你可以用：

```
ALTER ROLE myname SET enable_indexscan TO off;
```

这样就会保存该设置(但是不是立即设置)。然后，在这个角色随后的连接中就好像在会话开始之后都立即`SET enable_indexscan TO off`了一样。你也可以在会话中修改这个设置；它只是缺省。  
要撤销任何这样的设置，使用

```
ALTER ROLE rolename RESET varname;
```

请注意，对那些没有LOGIN属性的角色， 这些角色相关的缺省值几乎没什么用，因为它们从来不会被调用。
##权限##
在创建对象的时候，它会被赋予一个所有者。通常所有者就是执行创建语句的角色。对于大多数类型的对象，初始状态是只有所有者(或者超级用户)可以对该对象做任何事情。要允许其它用户使用这个对象，必须赋予相应的权限。   
系统里面有好几种不同类型的权限：SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,CREATE,CONNECT,TEMPORARY,EXECUTE和USAGE。有关PostgreSQL 支持的不同类型权限的更多信息，请参阅GRANT参考页。

使用GRANT命令赋予权限。 如果joe是一个现有的角色，而accounts 是一个现有的表，那么可以用下面的命令更新表的权限：

```
GRANT UPDATE ON accounts TO joe;
```

我们可以用特殊的名字PUBLIC 把对象的权限赋予系统中的所有角色。在权限声明的位置写上ALL 表示把适用于该对象的所有权限都赋予目标角色。

要撤销权限，使用REVOKE命令：

```
REVOKE ALL ON accounts FROM PUBLIC;
```

对象的所有者是一个特殊的权限(也就是修改和删除对象的权限)，总是隐含地属于所有者，不能赋予或者删除。但是所有者可以选择 撤销他自己拥有的普通权限，比如，把一个表做成对自己是只读的或者其它什么。  

只要对象的类型合适，我们就可以用一个ALTER命令给这个对象赋予一个新的所有者。超级用户总是能做这件事；普通的角色只能是在他们目前是该对象的所有者(或者是所有角色的成员)并且是新的所有角色 的成员的情况下才能做这个事情。
##角色成员##
把用户组合起来简化权限管理是个常用的便利方法:用这样的方法，权限可以赋予整个组，也可以对整个组撤消。在PostgreSQL里， 这些事情是通过创建代表一个组的角色， 然后赋予组角色的成员权限给独立的用户角色的方法实现的。

要设置一个组角色，首先创建角色：

```
CREATE ROLE name;
```

一般作为组使用的角色不应当具有LOGIN属性，虽然你可以设置它。

一旦组角色已经存在了，那么你就可以用 GRANT和REVOKE命令添加和撤消权限：

```
GRANT group_role TO role1, ... ;
REVOKE group_role FROM role1, ... ;
```

你还可以赋予成员权限给其它组角色(因为在组角色和非组角色之间没有实质的区别)。 唯一的制约是你不能建立循环的成员关系。另外，不允许给 PUBLIC角色赋予成员权限。

一个组角色的成员可以用两种方法使用组角色的权限。首先，一个组的每个成员都可以明确用`SET ROLE`临时"变成"该组的成员。  
在这个状态下，数据库会话具有该组角色的权限，而不是原始的登录角色权限，这个时候创建的数据库对象被认为是由组角色拥有，而不是登录角色。 

第二，拥有INHERIT属性的角色成员自动具有它们所属组角色的权限。 例如，假如我们做了下面的事情：

```
CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
```

那么在以角色joe连接之后，该数据库会话将立即拥有直接赋予joe的权限加上任何赋予admin的权限，因为joe"继承"了admin的权限。不过，赋予wheel 的权限不可用，因为即使joe是wheel 的一个间接成员， 但该成员关系是通过admin过来的，而该组有NOINHERIT属性。在

```
SET ROLE admin;
```

之后，该会话将只拥有那些已赋予admin的权限，而不包括那些已赋予joe的权限。在

```
SET ROLE wheel;
```

之后，该会话将只能使用已赋予wheel的权限，而不包括已赋予joe或admin的权限。 原来的权限可以用下列之一恢复：

```
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
```

Note: SET ROLE命令总是允许选取任意登录角色直接或者间接所在的组角色。因此，在上面的例子里，我们没必要在变成wheel之前先变成admin。

Note: 在SQL标准里，在用户和角色之间有明确的区别，并且用户并不会自动继承权限，而角色可以。这个行为在PostgreSQL里面可以通过给予那些当作SQL 角色使用的角色以INHERIT属性，而给予当作SQL用户使用的角色以NOINHERIT属性来实现。  
不过，PostgreSQL缺省是给予所有角色INHERIT属性，目的是和8.1之前的版本向下兼容，那些版本里，用户总是能使用他们所在组被赋予的权限。

角色属性LOGIN, SUPERUSER, CREATEDB可以被认为是特殊的权限， 但是它们从来不会像数据库对象上的普通权限那样继承。你必须明确地SET ROLE到一个特殊的角色，这个角色应该是拥有这些属性的角色，然后才能利用这些属性。继续上面的例子， 我们也可以选择给admin角色赋予CREATEDB和CREATEROLE 权限。然后，以joe连接的会话不会立即有这些权限，只有在SET ROLE admin之后才有。

要删除一个组角色，用DROP ROLE命令：

```
DROP ROLE name;
```

任何在组角色里面的成员关系都会自动撤消(但是成员角色自己则不受影响)。 不过，请注意任何组角色拥有的对象都必须首先删除或者赋予其它所有者； 并且任何给该组角色赋予的权限都必须撤消。