构造过程抽象.md
##程序设计的基本元素##
计算过程是存在于计算机里的一类抽象事物,在其演变过程中,这些过程会去操作一些被称为数据的抽象事物。人们创造出一些称为程序的规则模式,以指导这类过程的进行。  
1个强有力的程序设计语言,不仅是1种指挥计算机执行任务的方式,它还应该称为1种框架,使我们能够在其中组织自己有关计算过程的思想。每1种强有力的语言都为此提供了3种机制:

- 基本表达形式,用于表示语言所关心的最简单的个体。
- 组合的方法,通过它们可以从较简单的东西出现构造出复合的元素。
- 抽象的方法,通过它们可以为复合对象命令,并将它们当作单元去操作。

在程序设计中,我们需要处理2类要素:过程和数据.非形式地说,数据是1种我们希望去操作的东西,而过程就是有关操作这些数据的规则的描述。这样,任何强有力的程序设计语言都必须能表述基本的数据和基本的过程,还需要提供对过程和数据进行组合和抽象的方法。

###表达式###
你可以键入的1种基本表达式就是数,更准确的说,你键入的是由数字组成的表达式,它表示的是以10作为基数的数。  
你可以用表示基本过程的表达形式,将表达数的表达式组合起来,形成复合表达式,以表示要把有关过程应用于这些数。例如:

```
(+ 137 349)        ->486
```

像上面这样的表达式称为组合式,其构成方式就是用1对括号括起来一些表达式,形成1个表,用于表示1个过程应用。在表里最左的元素称为运算符,其他元素都称为运算对象。  
将运算符放在所有运算对象左边,这种形式称为前缀表示。  
即使对于非常复杂的表达式,解释器也总是按同样的基本循环运作:从终端读入1个表达式,对这个表达式求值,而后打印出得到的结果。这种运作模式常常被人们说成是解释器运行在1个读入-求值-打印循环之中。
###命名和环境###
程序设计语言中1个必不可少的方面,就是它需要提供一种通过名字去使用计算对象的方式,我们将名字标识符称为变量,它的值也就是它所对应的那个对象。  
defun是我们所用的语言里最简单的抽象方法,它允许我们用1个简单的名字去引用1个组合运算的结果。实际上,构造1个复杂的程序,也就是为了去一步步地创建出越来越复杂的计算性对象。解释器使这种逐步的程序构造过程变得非常方便,因为我们可以通过一系列交互式动作,逐步创建起所需要的名字-对象关联。  
我们可以将值与符号关联,而后又能提取出这些值,这意味着解释器必须维护某种存储能力,以便保持有关的名字-值对偶的轨迹。这种存储被称为环境,更准确的说是全局环境。
###组合式的求值###
解释器要求值1个组合式,做下面的事情:

1. 求值该组合式的各个子表达式。
2. 将作为最左子表达式(运算符)的值的那个过程应用于相应的实际参数。所谓实际参数也就是其他子表达式(运算对象)的值。

即使是1条这么简单的规则,也显示出计算过程的一些具有普遍性的重要问题。首先,由上面的第1步可以看到,为了实现对1个组合式的求值过程,我们必须先对组合式里的每个元素执行同样的求值过程。因此,在性质上,这一求值过程是递归的。也就是说,它在自己的工作步骤中,包含着调用这个规则本身的需要。  
对于初学者,应该指出的关键一点是,环境所扮演的角色就是确定表达式中各个符号的意义。  
一般性求值规则的这种例外称为特殊形式,defun是至今我们已经看到的唯一的1种特殊形式。下面还将看到另外一些特殊形式,每个特殊形式都有其自身的求值规则,各种不同种类的表达式组成了程序设计语言的语法形式(每种有着与之相关联的求值规则)。
###复合过程###
我们已经看到了Lisp里的某些元素,它们必然会出现在任何1种强有力的程序设计语言里。这些东西包括:

1. 数和算术运算是基本的数据和过程。
2. 组合式的嵌套提供了1种组织起多个操作的方法。
3. 定义是1种受限的抽象手段,它为名字关联相应的值。

现在我们来学习过程定义,这是1种威力更加强大的抽象技术。通过它可以为复合操作提供名字,而后就可以将这样的操作作为1个单元使用了。  
过程定义的一般形式是:

<pre>(defun (<name><formal parameters>)<body>)</pre>
其中`<name>`是1个符号,过程定义将在环境中关联这个符号。  
`<formal parameters>`(形式参数)是一些名字,它们用在过程体中,用于表示过程应用时与它们对应的各个实际参数。  
`<body>`是1个表达式,在应用这一过程时,这一表达式中的形式参数将用与之对应的实际参数取代,对这样取代后的表达式的求值,产生出这个过程应用的值。  
`<name>`和`<formal parameters>`被放在一对括号里,称为1组,就像实际调用被定义过程时的写法。
###过程应用的代换模型###
为了求值1个组合式(其运算符是1个复合过程的名字),解释器的工作方式采用与以运算符名为基础过程的组合式一样的计算过程。也就是说,解释器将对组合式的各个元素求值,而后将得到的那个过程(也就是该组合式里运算符的值)应用于那些实际参数(即组合式里那些运算对象的值)。  
对于复合过程,过程应用的计算过程是:

- 将复合过程应用于实际参数,就是在将过程体中的每个形参用相应的实参取代之后,对一过程体求值。

上述描述的这种计算过程称为过程应用的代换模型。但这里还需要强调1点:

1. 代换的作用只是为了帮助我们领会过程调用中的情况,而不是对解释器实际工作方式的具体描述。通常的解释器都不采用直接操作过程的正文,用值去代换形式参数的方式去完成对过程调用的求值。在实际中,它们一般采用提供形式参数的局部环境的方式,产生代换的效果。

####应用序和正则序####
按照"完全展开而后归约"的求值模型称为正则序求值,与之对应的是现在解释器里实际使用的"现求值参数而后应用"的方式,它称为应用序求值。  
Lisp采用应用序求值,部分原因在于这样做能避免对于表达式的重复求值,例如上面的(+ 5 1)和(* 5 2)的情况,从而可以提高一些效率。
###条件表达式和谓语###

7. 过程作为黑箱抽象

##过程与它们所产生的计算##
在Lisp里有着一种针对这类情况分析的特殊形式,称为cond(表示条件),其使用形式如下:

```
(defun (abs x)
   (cons ((> x 0) x)
         ((= x 0) 0)
         ((< x 0) (-x))))
```

条件表达式的一般性形式为:

<pre>cond (<p1><e1>)
          (<p2><e2>)
          ...
          (<pn><en>))
</pre>

这里首先包含了1个符号cond,在它之后跟着一些称为子句的用括号括起来的表达式对偶(`<p><e>`).在每个对偶中的第1个表达式是1个谓语,也就是说,这是1个表达式,它的值将被解释为真或者假。  
条件表达式的求值方式如下:首先求值谓语`<p1>`,如果它的值是false,那么就去求值`<p2>`,如果`<p2>`的值为false就去求值`<p3>`.这一过程将继续做下去,直到发现了某个谓语的值为真为止.此时解释器就返回相应子句的序列表达式`<e>`的值,以这个值作为整个条件表达式的值。如果没有找到值为真的`<p>`,cond的值就没有定义。  
我们用术语谓词指那些返回真或假的过程,也指那种能求出真或假的值的表达式。求绝对值的过程abs使用了基本谓语>、<和=,这几个谓词都以2个数为参数,分别检查第1个数是否大于、小于、等于第2个数,并据此分别返回真或者假。  
写绝对值函数的另1个方式是:

```
(define (abs x)
    (cond ((< x 0)(-x))
         (else x)))
```

用自然语言来说,也就是"如果x小于0就返回-x,否则就返回x".else是1个特殊符号,可以用在cond的最后1个子句`<p>`的位置,这样做时,如果该cond前面的所有子句都被跳过,它就会返回最后子句中的`<e>`的值。  
下面是又一种绝对值函数的方式:

```
(define (abs x)
    (if (< x 0)
        (-x)
        x))
```

这里采用的是特殊形式if,它是条件表达式的1种受限形式,适用于分情况分析中只有2个情况的需要。if表达式的一般形式是:

<pre>(if <predicate><consequent><alternative>)</pre>

在求值1个if表达式时,解释器从求值其`<predicate>`部分开始,如果`<predicate>`得到真值,解释器就去求值`<consequent>`并返回其值,否则它就去求值`<alternative>`并返回其值。  
过程的形式参数在过程体里扮演着一种非常特殊的角色,在这里,形式参数的具体名字是什么,其实完全没有关系。这样的名称称为约束变量,因此我们说,一个过程的定义约束了它的所有形式参数。  
如果在1个完整的过程定义里将某个约束变量统一换名,这一过程定义的意义将不会有任何改变。如果1个变量不是被约束的,我们称它为自由的。  
1个名字的定义被约束于那一集表达式称为这个名字的作用域。在1个过程定义里,被声明为这个过程的形式参数的那些约束变量,就以这个过程的体作为它们的作用域。
####内部定义和块结构####
这种嵌套的定义称为块结构,它是最简单的名字包装问题的1种正确解决方式。实际上,在这里还潜藏着1个很好的想法,除了可以将所用的辅助过程定义放到内部,我们还可能简化它们。我们可以让x作为内部定义的自由变量,这样在外围的函数调用时,x由实际参数得到自己的值,这种方式称为词法作用域。
##过程与它们所产生的计算##
1个过程就是1个模式,它描述了1个计算过程的局部演化方式,描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。在有了1个刻画计算过程的过程描述之后,我们当然希望能做出一些有关这一计算过程的整体或全局行为的论断。一般来说这是非常困难的,但我们至少还是可以试着去描述过程演化的一些典型模式。
###线性的递归和迭代###
首先考虑由下面表达式定义的阶乘函数:
<pre>$$n!=n\times(n-1)\times(n-2)\times3\times2\times1$$</pre>
计算阶乘的方式有许多种,1种最简单方式就是利用下述认识:对于1个正整数n,n!就等于n乘以(n-1)!;  
这样,我们就能通过算出(n-1)!,并将其结果乘以n的方式算出n!.如果再注意到1!就是1,这些认识就可以直接翻译成1个过程了:

```
(define (factorial n)
    (if (= n 1)
     1
     (* n (factorial (- n 1)))))
```

现在让我们采用另1种不同的观点来计算阶乘，我可以将计算阶乘n!的规则描述为:先乘起1和2,而后将得到的结果乘以3,而后再乘以4,这样下去直到达到n.更形式的地说,我们要维持着1个变动的乘积product,以及1个从1到n的计数器counter,这一计算过程可以描述为counter和product的如下变化,从一步到下一步,它们都按照下面规则改变:
<pre>
$$product\leftarrow counter\times product$$
$$counter\leftarrow counter+1$$
</pre>
可以看到,n!也就是计数器counter超时n时乘积product的值。我们又可以将这一描述重构为1个计算阶乘的过程:

```
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

与前面一样,我们也可以应用替换模型来查看6!的计算过程。

<pre>
(factorial 6)
(factorial 1 1 6)
(factorial 1 2 6)
(factorial 2 3 6)
(factorial 6 4 6)
(factorial 24 5 6)
(factorial 120 6 6)
(factorial 720 6 6)
720
</pre>

现在对这2个计算过程做1个比较,从1个角度看,它们并没有很大差异:二者计算的都是同1个定义域里的同1个数字函数,都需要使用与n正比的步骤数目去计算出n!.确实,这2个计算过程甚至采用了同样的乘运算序列,得到了同样的部分乘积序列。但在另1方面,如果我们考虑这2个计算过程的形状,就会发现它们的进程情况大不相同。  
考虑第1个计算过程,代换模型揭示出1种先逐步展开后收缩的形状.在展开阶段里,这一计算过程构造起1个推迟进行的操作所形成的链条,收缩阶段表现为这些运算的实际执行。这种类型的计算过程由1个推迟执行的运算链条刻画,称为1个递归计算过程。要执行这种计算过程,解释器就需要维护好那些以后将要执行的操作的轨迹。在计算阶乘n!时,推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息量。这个长度随着n的值而线性增长(正比于n),就像计算中的步骤数目一样,这样的计算过程称为1个线性递归过程。  
与之相对应,第2个计算过程里并没有任何增长或者收缩。对于任何1个n,在计算过程中的每1步,在我们需要保存轨迹里,所有东西就是变量product、counter和max-count的当前值。我们称这个过程为1个迭代计算过程。一般来说,迭代计算过程就是那种其状态可以用固定数目的状态变量描述的计算过程。而与此同时,y又存在一套固定的规则，描述了计算过程在1个状态到下1状态转换时,这些变量的更新方式,还有1个结束检测(可能的),它描述这一计算过程应该终止的条件。在计算n!时,所需的计算步骤随着n线性增长,这种过程称为线性迭代过程。  
我们还可以从另1个角度来看这2个过程之间的对比.在迭代的情况里,在计算过程中的任何一点,那几个程序变量都提供了有关计算状态的1个完整描述。如果我们令上述计算在某2个步骤之间停下来,要想重新唤醒这一计算,只需要解释器提供有关这3个变量的值。而对于递归计算过程而言,这里还存在着另外的一些隐含信息,它们并未保存在程序变量里,而是由解释器维持着,指明了在所推迟的运算所形成的链条里的漫游中,这一计算过程处在何处.这条链条越长,需要保存的信息也就越多。  
在做迭代和递归之间的比较时,我们必须当心,不要搞混了递归计算过程的概念和递归过程的概念。当我们说1个过程是递归的时候,论述的是1个语法形式的事实,说明这个过程的定义中(直接或者间接的)引用了该过程本身.在说某一计算过程具有某种模式时(例如,线性递归),我们说的是这一计算过程的进展方式,而不是相应过程书写上的语法形式。当我们说某个递归过程(例如fact-iter)将产生出1个迭代的计算过程,可能会使人感到不舒服。然而这一计算过程确实是迭代的,因为它的状态能由其中的3个状态变量完全刻画,解释器在执行这一计算过程中,只需要保持这3个变量的轨迹就足够了。
###树形递归###
另1种常见的计算模式称为树形递归。作为例子,现在考虑斐波那契数列(Fibonacci)的计算.这一序列中的每个数都是前面2个数之和:
$$0,1,1,2,3,5,8,13,21...$$
我们可以马上就可以将这个定义翻译为1个计算斐波那契数的递归过程:

```
(define (fib n)
  (cons ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

考虑这一计算的模式。为了计算(fib 5),我们需要计算出(fib 4)和(fib 3)。为了计算(fib 4),又需要计算(fib 3)和(fib 2).一般而言,这一展开过程看起来像1颗树.  
上述过程作为典型的树形递归具有教育意义,但它确实一种很糟糕的计算斐波那契数的方法,因为它做了太多的冗余计算。在上图中,求(fib 3)差不多是这里的一半工作,这一计算整个地重复做了2次。  
一般说,树形递归计算过程所需的步骤数将正比于书中的结点数,其空间需求正比于树的最大深度。  
我们页可以规划出1种计算斐波那契数的迭代计算过程,其基本思想就是用1对整数a和b,将它们分别初始化为Fib(1)=1和Fib(0)=0,而后反复地同时使用下面变换规则:
$$a\leftarrow a+b$$
$$b \leftarrow a$$
不难证明,在n次应用了这些变换后,a和b将分别等于Fib(n+1)和Fib(n).因此,我们可以用下面过程,以迭代方式计算斐波那契数:

```
(define (fib n)
   (fib-iter 1 0 n))

(define (fib-iter a b count)
   (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))
```

计算Fib(n)的这种方法是1个线性迭代。当我们考虑的是在层次结构性的数据上操作,而不是对数操作时,就会发现树形递归计算过程是1种自然的、威力强大的工具。即使是对于数的计算,树形递归计算过程页可能帮助我们理解和设计程序。
###增长的阶###
前面的一些例子说明,不同的计算过程在消耗计算资源的速率上可能存在着巨大差异。描述这种差异的一种方便方式是用增长的阶的记法,以便我们理解在输入变大时,某一计算过程所需资源的粗略度情况。
###最大公约数##
2个整数a和b的最大公约数(GCD)定义为能除尽这2个数的那个最大的整数。例如,16和28的GCD就是4.找出2个整数的GCD的1种方式就是对它们做因数分解,并从中找出公共因子。  
这一算法的思想基于下面的观察:如果r是a除以b的余数,那么a和b的公约数正好也是b的r的公约数。因此,我们可以借助于等式:
$$GCD(a,b)=GCD(b,r)$$
这就把1个GCD的计算问题连续地归约到越来越小的整数对的GCD的计算问题。例如:

<pre>
GCD(206,40)=GCD(40,6)
           =GCD(6,4)
           =GCD(4,2)
           =GCD(2,0)
           =2
</pre>

将GCD(206,40)归约到GCD(2,0),最终得到2.可以证明,从任意2个正整数开始,反复执行这种归约,最终将产生出1个数对,其中的第2个数是0,此时的GCD就是另1个数。这一计算GCD的方法称为欧几里得算法。  
不难将欧几里得算法写成1个过程:

```
(define (gcd a b)
  (if (= b 0)
   a
   (gcd b (remainder a b))))
```

这将产生1个迭代计算过程,其步数依所涉及的数的对数增长。
##用高阶函数做抽象##
我们已经看到,在作用上,过程也是1种抽象,它们描述了1些对于数的复合操作,但又并不依赖于特定的数。例如,在定义:

```
(define (cube x)(* x x x))
```

我们讨论的并不是某个特定数值的立方,而是对任意的数得到其立方的方法,而是对任意的数得到其立方的方法。当然,我们也完全可以不去定义这一过程,而总是写出下面这样的表达式:

```
(* 3 3 3)
(* x x x)
(* y y y)
```

并不明确地提出cube.但是这样做将把自己置于1个非常糟糕的境地,迫使我们永远在语言恰好提供了那些特定基本操作(例如这里的乘法)的层面上工作,而不是基于更高级的操作去工作。  
人们对功能强大的程序设计语言有1个必然要求,就是能为公告的模式命名,建立抽象,而后直接在抽象的层次上工作。过程提供了这种能力,这也是为什么除最简单的程序语言外,其它语言都包含定义过程的机制的原因。  
经常有一些同样的程序设计模式能用于若干不同的过程,为了把这种模式描述为相应的概念,我们就需要构造出这样的过程,让它们以过程作为参数,或者以过程作为返回值。这类能操作的过程称为高阶过程。
###过程作为参数###
考虑以下的3个过程,第1个计算从a到b的各整数之和:

```
(define (sum-integers a b)
  (if (> a b)
   0
   (+ a (sum-intergers (+ a 1) b))))
```

第2个计算给定范围内的整数的立方之和:

```
(define (sum-cube a b)
  (if (> a b)
   0
   (+ (cube a)(sum-cubes (+ a 1) b))))
```

第3个计算下面的序列之和:
它将非常缓慢收敛到π/8:

```
(define (pi-sum a b)
 (if (> a b)
  0
  (+ (/ 1.0 (* a (+ a 2)))(pi-sum (+ a 4) b))))
```

可以明显看出,这3个过程共享着一些公共的基础模式。它们的很大一部分是共同的,只是所用的过程名字上不一样:用于从a算出需要要加的项的函数,还有用于提供下1个a值的函数。我们可以填充下面模板中的各空位,产生出上面的各个过程。

```
(define (<name> a b)
   (if (> a b)
    0
    (+ (<name> a)
       (<name> (<next> a) b))))
```

这种公共模式的存在是1种很强的证据,说明这里实际上存在1种很有用的抽象,在那里等着浮现出来。确实,数学家很早就认识到序列求和中的抽象模式,并提出了专门的求和记法。  
求和记法的威力在于它使数学家能去处理求和的概念本身,而不只是某个特定的求和。  
与此类似,作为程序模式,我们也希望所用的语言足够强大,能用于写出1个过程,去表述求和的概念,而不是只能写计算特定求和的过程。我们确实可以在所用的过程语言中做到这些,只要按照上面给出的模式,将其中的空位翻译为形式参数:

```
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
```

请注意,sum仍然以作为下界和上界的参数a和b为参数,但是这里又增加了过程参数term和next.使用sum的方式与其他函数完全一样.例如,我们可以用它去定义sum-cubes(还需要1个过程inc,它得到参数值加一):

```
(define (inc n)(+ n 1))
(define (sum-cubes a b)
  (sum cube a inc b))
```

我们可以用这个过程算出从1到10的立方和:

```
(sum-cubes 1 10)        ->3025
```

一旦有了sum,我们就能用它作为基本构件,去形式化其他概念。
###用lambda构造过程###
我们通过引入1种lambda特殊形式来完成这类描述,这种特殊形式能够创建出所需要的过程。利用lambda,我们就能按照如下方式写出所需的东西:

```
(lambda (x) (+ x 4))
(lambda (x) (/ 1.0 (* x (+ x 2))))
```

一般来说,lambda用与define同样的方式创建过程,除了不为有关过程提供名字之外:

```
(lambda (<formal-parameters>)<body>)
```

这样得到的过程与通过define创建的过程完全一样,仅有的不同之处,就是这种过程没有与环境中的任何名字相关联。事实上,

```
(define (plus x)(+ x 4))
```

等价于

```
(define plus (lambda (x) (+ x 4))
```

像任何以过程为值的表达式一样,lambda表达式可用作组合式的运算符,例如:

```
((lambda (x y z)(+ x y (square z))) 1 2 3)       ->12
```

####用let创建局部变量####
lambda的另1个应用是创建局部变量.在1个过程里,除了使用那些已经约束为过程参数的变量外,我们常常还需要另外一些局部变量.例如,嘉定我们希望计算函数:
$$f(x,y)=x(1+xy)^{2}+y(1-y)+(1+xy)(1-y)$$
可能就希望将它表述为:
$$a=1+xy$$
$$b=1-y$$
$$f(x,y)=xa^{2}+yb+ab$$
在写计算f的过程时,我们可能希望还有几个局部变量,不止是x和y,还有中间值的名字如a和b.做到这些的1种方式就是利用辅助过程去约束局部变量:

```
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
```

当然我们也可以使用1个lambda表达式,用以描述约束局部变量的匿名过程。这样,f的体就变成了1个简单的对该过程的调用:

```
(define (f x y)
 (lambda (a b)
  (+ (* x (square a))
     (* y b)
     (* a b)))
  (+ 1 (* x y))
  (- 1 y)))
```

这一过程非常有用,因此语言里有1个专门的特殊形式称为let,使这种编程方式更为方便。利用let,过程f可以写为:

```
(define (f x y)
 (let ((a (+ 1 (* x y)))
       (b (- 1 y)))
  (+ (* x (square a))
     (* y b)
     (* a b))))
```

let表达式的一般形式是:

```
(let ((<var1><exp1>)
      (<var2><exp2>)
      ...
      (<varN><expN>))
      <body>)
```

let表达式的第1个部分是个名字-表达式对偶的表,当let被求值时,这里的每个名字都被关联于对应表达式的值。在将这些名字约束为局部变量的情况下求值let的体。这一做法正好使let表达式被解释为替代如下表达式的另1种语法形式:

```
((lambda (<var1>...<varN>)
  <body>)
  <exp1>
    ...
  <expN>)
```

这样,解释器里就不需要为提供局部变量增加任何新机制.let表达式只是作为其基础的lambda表达式的语法外衣罢了。  
根据这一等价关系,我们可以认为,由let表达式描述的变量的作用域就是该let的体,这也意味着:

- let使人能在尽可能接近其使用的地方建立局部变量约束。
- 变量的值是在let之外计算的。

