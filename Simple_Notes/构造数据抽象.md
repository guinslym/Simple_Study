构造数据抽象.md
许多程序在设计时就是为了模拟复杂的现象,因此它们就常常需要构造起一些计算对象,这些对象都是由一些部分组成的,以便去模拟真实世界里的那些具有若干侧面的现象。这样,与我们在第1章里所做的事情(通过将一些过程组合起来形成复合的过程,以这种方式构造起各种抽象)相对应,本章将重点转到各种程序设计语言都包含的另1个关键方面:讨论它们所提供的,将数据对象组合起来,形成复合数据的方式。
为什么在程序设计语言里需要复合数据呢?与我们需要复合过程的原因一样:同样是为了提升我们在设计程序时所位于的概念层次,提升设计的模块性,增强语言的表达能力。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样,能够构造复合数据的能力,也将使我们得以在比语言提供的基本数据对象更高的概念层次上,处理与数据有关的各种问题。
现在考虑设计1个系统,它完成有理数的算术。我们可以设想1个运算add-rat,它以2个有理数为参数,产生出它们的和。从基本数据出发,1个有理数可以看作2个整数,1个分子和1个分母。这样,我们就可以设计出1个程序,其中的每个有理数用2个整数表示(1个分子和1个分母),而其中的add-at用2个过程实现(1个产生和数的分子,另1个产生和数的分母)。然而,这样做下去会非常难受,因为我们必须明确地始终记住哪个分子与哪个分母相互对应。在1个需要执行大量有理数操作的系统里,这种记录工作将会严重地搅乱我们的程序,而这些麻烦又与我们心中真正想做的事情毫无关系。如果能将1个分子和1个分母粘在一起,形成1个对偶——1个复合数据对象——事情就会好得多了。因为这样,程序中对有理数的操作就可以按照将它们作为1个概念单位的方式进行了。
复合数据的使用也使我们能进一步提高程序的模块性。如果我们可以直接在将有理数本身当做对象的方式下操作它们,那么也就可能把处理有理数的那些程序部分,与有理数如何表示的细节(可能是表示为1对整数)隔离开。这种将程序中处理数据对象的表示的部分,与处理数据对象的使用的部分相互隔离的技术非常具有一般性,形成了1种称为数据抽象的强有力的设计方法学。我们将会看到,数据抽象技术能使程序更容易设计、维护和修改。
复合对象的使用将真正提高程序设计语言的表达能力。考虑形成线性组合`ax+by`,我们可能想到写1个过程,让它接受a、b、x和y作为参数并返回`ax+by`的值。如果以数值作为参数,这样做没有任何困难,因为我们立刻就能定义出下面的过程:

```
(define (linear-combination a b x y)
  (+ (* a x)(* b y)))
```

但是,如果我们关心的不仅仅是数,假定在写这个过程时,我们希望表述的是基于加和乘形成线性组合的思想,所针对的可以是有理数、复数、多项式或者其他东西,我们可能将其表述为下面形式的过程:

```
(define (linear-combination a b x y)
  (add (mul a x)(mul b y)))
```

其中的add和mul不是基于过程+和*,而是某些更复杂的东西,它们能对通过参数a、b、x和y送来的任何种类的数据执行适当的操作。在这里最关键的是,linear-combination对于a、b、x和y需要知道的所有东西,也就是过程add和mul能够执行适当的操作。从过程linear-combination的角度看,a、b、x和y究竟是什么,其实根本就没有关系,至于它们是怎么基于更基础的数据表示就更没有关系了。
这个例子说明,为什么1种程序设计语言能够提供直接操作复合对象的能力是如此的重要,因为没有这种能力,我们就没有办法让1个linear-combination这样的过程将其参数传递给add和mul,而不必知道这些参数的具体细节结构。
我们将会看到,形成复合数据的关键就在于,程序设计语言里应该提供了某种黏合剂,它们可以用于把一些数据对象组合起来,形成更复杂的数据对象。黏合剂可能有很多不同的种类。确实的,我们还会发现怎样去构造出根本没有任何特定数据操作,只是由过程形成的复合数据。这将进一步模糊过程和数据之间的划分。
我们还要探索表示序列和树的一些常规技术。在处理复合数据中的1个关键性思想就是闭包的概念。也就是,用于组合数据对象的黏合剂不但能用于组合基本的数据对象,同样页可以用于复合的数据对象。另1关键思想是,复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。我们将通过给出1个利用闭包概念的简单图形界面语言的方式,阐释有关的思想。
而后我们要引进符号表达式,进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号,不一定是数。我们将探索表示对象集合的各种不同方式,由此可以发现,就像1个给定的数字函数可以通过许多不同的计算过程计算一样,对于一个给定的数据结构,也可以有许多方式将其表示为简单对象的组合,而这种表示的选择,有可能对操作这些数据的计算过程的时间和空间需求造成重大的影响.我们将在符号微分、集合的表示和信息编码的上下文中研究这些思想。
随后,我们将转去处理在1个程序的不同部分可能采用不同表示的数据的问题,这就引出了实现通用型操作的需要,这种操作必须能处理许多不同的数据类型。为了维护模块性,通用型操作的出现,将要求比只有简单数据抽象更强大的抽象屏障。特别地,我们将介绍数据导向的程序设计。
这是1种技术,它能允许我们独立地设计每1种数据表示,而后用添加的方式将它们组合进去(也就是说,不需要任何修改)。
为了展示这一系统设计方法的威力,在本章的最后,我们将用已经学到的东西实现1个多项式符号算术的程序包,其中多项式的系数可以是整数、有理数、复数甚至还可以是其他多项式。
##数据抽象导引##
我们可以这样造成1个抽象,它将这一过程的使用方式,与该过程究竟如何通过更基本的过程实现的具体细节相互分离。针对复合数据的类似概念被称为数据抽象。数据抽象是1种方法学,它使我们能将1个复合对象的使用,与该数据对象怎样由更基础的数据对象构造起来的细节隔离来。
数据抽象的基本思想,就是设法构造出一些使用复合数据对象的程序,使它们就像是在抽象数据上操作一样。也就是说,我们的程序中使用数据的方式应该是这样的,除了完成当前工作所必要的东西之外,它们不对使用数据做任何多余的假设。与此同时,1种具体数据表示的定义,也应该与程序中使用的方式无关。在我们的系统里,这样2个部分之间的界面将是1组过程,称为选择函数和构造函数,它们在具体表示之上实现抽象的数据。
###序对###
为了在具体的层面上实现这一数据抽象,我们所用的语言提供了1种称为序对的复合结构,这种结构可以通过基本过程cons构造出来。过程cons取2个参数,返回1个包含这2个参数作为其成分的复合数据对象。如果给了1个序对,我们可以用基本过程car和cdr,按如下方式提取出其中各个部分:

```
(define x (cons 1 2))
(car x)       ->1
(cdr x)       ->2
```

请注意,1个序对也是1个数据对象,可以像基本数据对象一样给它1个名字且操作它。进一步说,还可以用cons去构造出那种其元素本身就是序对的序对,并继续这样做下去。

```
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))        ->1
(car (cdr z))        ->3
```

名字cons表示构造(construct).名字car和cdr则来自Lisp最初在IBM 704机器上的实现,在这种机器有1种取址模式,使人可以访问1个存储地址中的地址(address)部分和减量(decrement)部分。car表示Content of Address part of Register(寄存器的地址部分的内容),cdr读作(could-cr)表示Content of Decrement part of Register(寄存器的减量部分的内容)。
###抽象屏障###
一般而言,数据抽象的基本思想就是为了每1类数据对象标识出一组操作,使得对这类数据对象的所有操作都可以基于它们表述,而且在操作这些数据对象时也只使用它们。
下图形象地表示了有理数系统的结构。其中的水平线表示抽象屏障,它们隔离了系统中不同的层次。在每1层上,这种屏障都能把使用数据抽象的程序(上面)与实现数据抽象的程序(下面)分开来。
这一简单思想有许多优点.第1个优点是这种方法使程序很容易维护和修改。任意1种比较复杂的数据结构,都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。当然,表示方式的选择会对操作它的程序产生影响,这样,如果后来表示方式改变了,所有受影响的程序也都需要随之改变。对于大型程序而言,这种工作将非常耗时,而且代价极其昂贵,除非在设计时就已经依赖于表示的成分限制到很少的一些程序模块上。
###数据意味着什么###
那么数据究竟意味着什么,说它就是由给定的构造函数和选择函数所实现的东西还是不够的。显然,并不是任意的3个过程都适合作为有理数实现的基础。在这里,我们需要保证,如果从1对整数n和d构造出1个有理数x,那么抽取出的number和denom并将它们相除,得到的结果应该与n除以d相同。换句话说,make-rat、number和denom必须满足下面条件,对任意整数n和任意非零整数d,如果x是(make-rat n d),那么:
$$\dfrac{(number x)}{(denom x)}=\dfrac{n}{d}$$
事实上,这就是为了能成为适宜表示有理数的基础,make-rat、number和denom必须满足的全部条件。一般而言,我们总可以将数据定义为1组适当的选择函数和构造函数,以及为使这些过程成为1套合法表示,它们就必须满足的一组特定条件。
这一观点不仅可以服务于高层数据对象的定义,例如有理数,同样也可用于底层的对象。请考虑序对的概念,我们在前面用它定义有理数。我们从来都没有说序对究竟是什么,只说所用的语言为序对的操作提供了3个过程cons、car和cdr。有关这3个操作,我们需要知道的全部东西就是,如果用cons将2个对象粘接在一起,那么就可以借助于car和cdr提取出这2个对象。也就是说,这些操作满足的条件是:对任何对象x和y,如果z是(cons x y),那么(car z)就是x,而(cdr z)就是y.
然而,任何能满足上述条件的3个过程都可以成为实现序对的基础,下面这个令人吃惊的事实能够最好地说明这一点:我们完全可以不用任何数据结构,只使用过程就可以实现序对。下面是有关的定义:

```
(define (cons x y)
  (define (dispatch m)
   (cond ((= m 0) x)
         ((= m 1) y)
         (else (error "Argument not 0 or 1 --CONS" m))))
 dispatch)
(define (car z)(z 0))
(define (cdr z)(z 1))
```

过程的这一使用方式与我们有关数据应该是什么直观认识大相径庭。但不管怎么说,如果要求我们说明这确实是1种表示序对的合法方式,那么只需要验证,上述几个过程满足了前面提出的所有条件。
应该特别注意这里的1个微妙之处:由(cons x y)返回的值是1个过程,也就是那个内部定义的过程dispatch,它有1个参数,并能根据参数是0还是1,分别返回x或者y.
因此,序对的这一过程实现确实是1个合法的实现,如果只通过cons、car和cdr访问序对,我们将无法把这一实现与真正的数据结构区分开。
上面展示了序对的一种过程性表示,这并不意味我们所用的语言就是这样做的,而是说它确实可以这么做。这一过程性表示虽然有些隐晦,但它确实是一种完全合适的表示序对的方式,因为它满足了序对需要的所有条件.这一实例也说明可以将过程作为对象去操作,因此就自动地为我们提供了1种表示复合数据的能力。但实际上,数据的过程性表示将在我们的程序设计宝库里扮演一种核心角色.有关的程序设计风格通常称为消息传递。
##层次性数据和闭包性质##
正如在前面已经看到的,序对为我们提供了1种用于构造复合数据的基本粘结剂。图2-2展示了是1种以形象的形式看序对的标准方式,其中的序对是通过(cons 1 2)形成的。在这种称为盒子和指针表示方式中,每个对象表示1个指向盒子的指针。与基本对象相对应的盒子里包含着该对象的表示,例如,表示数的盒子里就放着那个具体的数。用于表示序对的盒子实际上是一对方盒,其中左边的方盒放着序对的car(指向car的指针),右边部分放着相应的cdr.
前面已经看到了,我们不仅可以用cons去组合起各种数值,也可以用它去组合其序对。作为这种情况的推论,序对就是1种通用的建筑砌块,通过它可以构造起所有不同种类的数据结构来。
我们可以建立元素本身也是序对的序对,这就是表结构得以作为1种表示工具的根本基础。我们将这种能力称为cons的闭包性质。一般来说,某种组合数据对象的操作满足闭包性质,那就说,通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。闭包性质是任何一种组合功能的威力的关键要素,因为它使我们能够建立起层次性的结构,这种结构由一些部分构成,而其中的各个部分又是由它们的部分构成,并且可以如此继续下去。

###序列的表示###
利用序对可以构造出的一类有用结构是序列,一批数据对象的1种有序汇集。显然,采用序对表示序列的方式很多,1种最直接的表示方式如下所示,其中用1个序对的链条表示出序列1,2,3,4,在这里,每个序对的car部分对应于这个链中的条目,cdr则是链中下1个序对。最后的1个序对的cdr用1个能辨明不是序对的值表示,标明序对的结束,在盒子指针图中用1条对角线表示,在程序里用变量nil的值。整个序列可以通过嵌套的cons操作构造起来:

```
(cons 1
  (cons 2
    (cons 3
      (cons 4 nil))))
```

通过嵌套的cons形成的这样1个序对称为1个表,Scheme为方便表的构造,提供了1个基本操作list,上面序列也可以通过(list 1 2 3 4)产生.一般说:

```
(list <a1><a2>...<aN>)
```
等价于:

```
(cons <a1> (cons <a2> (cons ... (cons <aN> nil) ...)))
```

Lisp系统通常用元素序列的形式打印出来,外面用括号括起。按照这种方式,图2-4里的数据对象将打印为(1 2 3 4):

```
(define one-through-four (list 1 2 3 4))
one-through-four        ->(1 2 3 4)
```

请当心,不要将表达式(list 1 2 3 4)和表(1 2 3 4)搞混了,后面这个表是对前面表达式求值得到的结果。如果想去求值表达式(1 2 3 4),解释器就会试图将过程1应用于参数2,3和4,这时会发出1个出错信号。
我们可以将car看作选取表的第1项的操作,将cdr看作是选取表中除去第1项之后剩下的所有项形成的子表。car和cdr的嵌套应用可以取出1个表里的第2、第3以及后面的各项。构造符cons可用于构造表,它在原有的表前面增加1个元素:

```
(car one-through-four)          ->1
(car (cdr one-through-four))    ->2
(cons 10 one-through-four)      ->(10 1 2 3 4)
(cons 5 one-through-four)       ->(5 1 2 3 4)
```

nil的值用于表示序对的链结束,它可以当作1个不包含任何元素的序列,空表。单词nil是拉丁词汇nihil的缩写,这个拉丁词汇表示什么也没有。

###层次性结构###
将表作为序列的表示序列作为1种约定的界面方式,可以很自然地推广到表示那些元素本身也是序列的序列。举例来说,我们可以认为对象((1 2) 3 4)是通过下面方式构造出来的:

```
(cons (list 1 2)(list 3 4))
```

这是1个包含3个项的表,其中的第1个项本身又是表(1 2).这一情况也由解释器的打印形式所肯定。图2-5用序对的语言展示了这一结构的表示形式。  
认识这种元素也是序列的序列的另1种方式,是把它们看作树。序列里的元素就是树的分支,而那些本身也是序列的元素就形成了树中的子树。图2-6显示的是将图2-5的结构看作树的情况。  
递归是处理树结构的1种很自然的工具,因为我们常常可以对于树的操作归结为对它们的分支操作,再将这种操作归结为对分支的分支的操作,如此下去,直至达到了树的叶子。作为例子,请比较一下2.2.1节的length过程与下面的counter-leaves过程统计出1棵树中树叶的数目:

``` 
(define x (cons (list 1 2)(list 3 4)))
(length x)         ->3
（count-leaves x)  ->4
(list x x)
(((1 2) 3 4)((1 2) 3 4))
(length (list x x))       ->2
(count-leaves (list x x)) ->8
```

为了实现count-leaves,可以先回忆一下length的递归方案:

- 表x的length是x的cdr的length加一。
- 空表的length是0.

count-leaves的递归方案与此类似,对于空表的值也相同:

- 空表的count-leaves是0.

但是在递归步骤中,当我们去掉1个表的car时,就必须注意1个car本身也可能是树,其树叶也需要考虑。这样,正确的归约步骤应该是:

- 对于树x的count-leaves应该是x的car的count-leaves与x的cdr的count-leaves之和。

最后,在通过car达到1个实际的树叶时,我们还需要另1种基本情况:

- 1个树叶的count-leaves是1.

###序列作为1种约定的界面###
我们一直强调数据抽象在对复合数据的工作中的作用,借助这种思想,我们就能设计出不会被数据表示的细节纠缠的程序,使程序能够保持很好的弹性,得以应用不同的具体表示上。  
信号处理工程师可能会发现,这种情况可以很自然地用流过一些级联的处理步骤的信号的方式描述,其中的每个处理步骤实现程序方案的一部分。如图2-7所示,对于第1个情况sum-odd-squares,我们从1个枚举器开始,它产生出由给定的树的所有树组成"信号"。这一信号流过1个过滤器,它将square过程应用于每个元素.这一映射的输出被馈入1个累积器,该装置用+将得到的所有元素组合起来,以初始的0开始。even-fibs的工作过程与此类似。  
一般来说,在这2个过程里,没有1个部分正好对应于信号流描述中的某1要素。我们的2个过程采用不同的方式分解了这个计算,将枚举工作散布在程序中各处,并将它与映射、过滤器和累积器混在一起。如果我们能够重新阻止这1程序,使得信号流结构明显表现在写出的过程中,将大大提高结果代码的清晰性。
####序列操作####
要组织好这些程序,使之能够更清晰地反应上面信号流的结构,最关键的1点就是将注意力集中在处理过程中从1个步骤流向下1个步骤的信号。如果我们使用一些表来表示这些信号,那么就可以利用表操作实现每1步骤的处理。举例来说,我们可以用2.2.1节的map过程实现信号流图中的映射步骤:

```
(map square (list 1 2 3 4 5))        ->(1 4 9 16 25)
```

过滤1个序列,也就是选出其中满足某个谓语的元素,可以按下面方式做:

```
(define (filter predicate sequence)
  (cond ((null? sequence) nil) 
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
         (else (filter predicate (cdr sequence)))))
```

例如,

```
(filter odd? (list 1 2 3 4 5))
(1 3 5)
```

累计工作实现如下:

```
(define (accumulate op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (accumulate op initial (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))     ->15
(accumulate * 1 (list 1 2 3 4 5))     ->120
(accumulate cons nil (list 1 2 3 4 5))->(1 2 3 4 5)
```

剩下的就是实现有关的信号流图,枚举出需要处理的数据序列。对于even-fibs,我们需要生成出1个给定区间里的整数序列,这一序列可以如下做出:

```
(define (enumerate-interval low high)
  (if (> low high)
   nil
   (cons low (enumerate-interval (+ low 1) hign))))

(enumerate-interval 2 7)         ->(2 3 4 5 6 7)
```

要枚举出1颗树的所有树叶,则可以用:

```
(define (enuerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))        ->(1 2 3 4 5)
```

现在,我们就可以像上面的信号流那样重新构造sum-odd-squares和even-fibs了。对于sum-odd-squares,我们需要枚举1棵树的树叶序列,过滤它,只留下序列中的奇数,求每个元素的平方,而后加起来得到的结果:

```
(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                 (filter odd?
                    (enumerate-tree tree)))))
```

对于even-fibs,我们需要枚举出从0到n的所有整数,对某个整数生成相应的斐波那契数,通过过滤只留下其中的偶数,并将结果积累在1个表里:

```
(define (even-fibs n)
  (accumulate cons
              nils
              (filter even?
                      (map fib
                          (enumerate-interval 0 n)))))
```

将程序表示为一些针对序列的操作,这样做的价值在于能帮助我们得到模块化的程序设计,也就是说,得到由一些比较独立的片段的组合构成的设计。通过提供一个标准部件的库,并使这些部件都有着一些能以各种灵活方式相互连接的约定界面,将能进一步推动人们去做模块化的设计。  
在工程设计中,模块化结构是控制复杂性的1种威力强大的策略。举例来说,在真实的信号处理应用中,设计者通常总是从标准化的过渡器和变换装置族中选出一些东西,通过级联的方式构造出各种系统。与此类似,序列操作也形成了1个可以混合和匹配使用的标准的程序元素库。例如,我们可以在另1个构造前n+1个斐波那契数的平方的程序里,使用取自过程sum-odd-squares和even-filbs的片段:

```
(define (list-flib-square n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
(list-fib-squares 10)       ->(0 1 1 4 9 25 64 169 441 1156 3025)
```

我们也可以重新安排有关的各个片段,将它们用在产生1个序列中所有奇数的平方之乘积的计算里:

```
(define (product-of-squares-of-odd-elements sequence)
   (accumulate * 
               1
               (map square
                 (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))       ->225
```

我们同样可以采用序列操作的方式,重新去形式化各种常规的数据处理应用。假定有1个人事记录的序列,现在希望找出其中薪水最高的程序员的工资数额.假定现在有1个选择函数salary返回记录中的工资数,另有谓语programmer?检查某个记录是不是程序员,此时我们就可以写:

```
(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                (filter programmers? records))))
```

这些例子给了我们一些启发,范围广大的许多操作都可以表述为序列操作。  
在这里,用表实现的序列被作为1种方便的界面,我们可以利用这种界面去组合起各种处理模块。进一步说,如果以序列作为所用的统一表示结构,我们就能将程序对于数据结构的依赖性局限到不多的几个序列操作上。通过修改这些操作,就可以在序列的不同表示之间转换,并保持程序的整个设计不变。
###框架###
1个框架可以用3个向量描述,1个基准向量和2个角向量。基准向量描述的是框架基准点相对于平面上某个绝对基准点的偏移量,角向量描述了框架的角相对于框架基准点的偏移量。如果2个角向量正交,这个框架就是矩形。否则它就是1个一般的平行四边形。  
我们将用单元正方形(0≤x,y≤1)里的坐标去描述图像。对于每个框架,我们要为它关联1个框架坐标映射,借助它完成有关图像的位移和伸缩,使之能够适配于这个框架。这一映射的功能就是把单位正方形变换到相应框架,锁采用的方法也就是将向量v=(x,y)映射到下面的向量和:
$$Origin(Frame)+x\timesEdge_{1}(Frame)+y\timesEdge_{2}(Frame)$$
例如,点(0,0)将被映射到给定框架的原点,(1,1)被映射到与原点对角的那个点,而(0.5,0.5)被映射到给定框架的中心点.我们可以通过下面过程建立起框架的坐标映射:

```
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
      (origin-frame frame)
      (add-vect (scale-vect (xcor-vect v)
                            (edgel-frame frame))
                (scale-vect (ycor-vect v)
                            (edgel2-frame frame))))))
```

请注意看,这里将frame-coord-map应用于1个框架的结构是返回了1个过程,它对于每个给定的向量返回了另1个向量.如果参数向量位于单位正方形里,得到的对应结果向量也将位于相应的框架里.例如:

```
((frame-coord-map a-frame)(make-vect 0 0))
```

返回的向量如下:

```
(origin-frame a-frame)
```

###画家###
1个画家被表示为1个过程,给了它1个框架作为实际参数,它就能通过适当的位移和伸缩,画出1幅与这个框架匹配的图像。也就说,如果p是1个画家而f是1个框架,通过f作为实际参数调用p,就能产生f中的p图像。  
基本画家的实现细节依赖于特定图形系统的各种特定和被画图像的种类。例如,假定现在有了1个过程draw-line,它能在屏幕上2个给定点之间画出1条直线,那么我们就可以利用它创建1个画折线图的画家,例如从通过下面的线段表创建出图2-10的wave画家:

```
(define (segments->painter segment->list)
  (lambda (frame)
    (for-each
        (lambda (segment)
          (draw-line
           ((frame-coord-map frame)(start-segment segment))
           ((frame-coord-map frame)(end-segment segment))))
           segment-list)))
```

这里所给出的线段都用相对于单位正方形的坐标描述,对于表中的每个线段,这个画家将根据框架坐标映射,对线段的各个端点做变换,而后在2个端点之间画1条直线。  
将画家表示为过程,就在这一图形语言中竖立起1道强有力的抽象屏障。这也使我们可以创建和混用基于各种图形能力的各种类型的基本画家。任何过程只要能取1个框架作为参数,画出某些可以伸缩后适合这个框架的东西,它就可以作为1个画家。
###强健设计的语言层次###
在上述的图像语言中,我们演习了前面介绍的有关过程和数据抽象的关键思想。其中的基本数据抽象和画家都用过程表示实现,这就使得该语言能以1种统一方式去处理各种本质上完全不同的画图能力。实现组合的方法也满足闭包性质,使我们很容易构造起各种复杂的设计。最后,用于做过过程抽象的所有工具,现在也都可用于组合画家的抽象手段。  
我们也对程序设计的另1个关键概念有了1点认识,这就是分层设计的问题。这一概念说的是,一个复杂的系统应该通过一系列的层次构造出来,为了描述这些层次,需要使用1系列语言。构造各个层次的方式,就是设法组合起来作为这一层次中部件的各种基本元素,而这样构造出的部件又可以作为另1个层次里的基本元素。在分层设计中,每个层次所用的语言都提供了1些基本元素,组合手段,还有对该层次中的适当细节做抽象的手段。
##符号数据
###引号###
如果我们能够构造出采用符号的复合数据,我们就可以有下面这类的表:

```
(a b c d)
(23 45 17)
((Norah 12)(Molly 9)(Anna 7)(Lauren 6)(Charlotte 4))
```

这些包含着符号的表看起来就像是我们语言里的表达式:

```
(* (+ 23 45)(+ x 9))
(define (fact n)(if (= n 1) 1 (* n (fact (- n 1)))))
```

为了能够操作这些符号,我们的语言里就需要有1种新元素,为数据对象加引号的能力。假定我们希望构造出表(a b),当然不能用(list a b)完成这件事,因为这一表达式将要构造出的是a和b的值的表,而不是这2个符号本身的表。在自然语言的环境中,这种情况也是众所周知的,在那里的单词和句子都可能看作语义实体,也可以看作是字符的序列(语法实体)。在自然语言里,常见的方式就是用引号表明1个词或者1个句子应作为文字看待,将它们直接作为字符的序列。例如说,John的第1个字母显然是J,如果我们对某人说大声说出你的名字,此时希望听到的是那个人的名字。如果说大声说你的名字,此时希望听到的就是词组你的名字。请注意,我们在这里不得不用嵌套的引号去描述别人应该说的东西。  
我们可以按照同样的方式,将表和符号标记为应该作为数据对象看待,而不是作为应该求值的表达式。然而,这里所用的引号形式与自然语言中的不同,我们只在被引用对象的前面放1个引号(按照习惯,在这里用单引号)。  
现在我们就可以区分符号和它们的值了:

```
(define a 1)
(define b 2)
(list a b)        ->(1 2)
(list 'a 'b)      ->(a b)
(list 'a b)       ->(a 2)
```

引号也可以用于复合对象,其中采用的是表的方便的输出表示方式:

```
(car '(a b c))     ->a
(cdr '(a b c))     ->(b c)
```

记住这些之后,我们就可以通过求值'()得到空表,这样就可以丢掉变量nil了。  
为了能对符号做各种操作,我们还需要用另1个基本过程eq?,这个过程以2个符号作为参数,检查它们是否为同样的符号。
##抽象数据的多重表示##
数据抽象屏障是控制复杂性的强有力工具,通过对数据对象基础表示的屏蔽,我们就可以将设计1个大程序的任务,分割为1组可以分贝处理的较小任务。但是,这种类型的数据抽象还不够强大有力,因为在这里说数据对象的基础表示并不一定总有意义。  
从1个角度看,对于1个数据对象也可能存在多种有用的表示方式,而且我们也可以希望所设计的系统能处理多种表示形式。举1个简单的例子,复数可以表示为2种几乎等价的形式:直角坐标形式(实部和虚部)和极坐标形式(摸和幅角)。有时采用直角坐标形式更合适,有时极坐标形式更方便.
###复数的表示###
与有理数一样,复数也可以很自然地用有序对表示。我们可以将复数集合设想为1个带有2个坐标轴(实轴和虚轴)的2维空间。按照这一观点,复数`z=x+iy`(其中$i^{2}=-1$)可看作这个平面上的1个点,其中的实坐标是x而虚坐标为y.在这种表示下,复数的加法就可以归结为2个坐标分别相加:

<pre>实部(z1+z2)=实部(z1)+实部(z2)
虚部(z1+z2)=虚部(z1)+虚部(z2)
</pre>

在需要乘2个复数时,更自然的考虑是采用复数的极坐标形式,此时复数用1个模和1个幅角表示(图2-20中的r和A)。2个复数的乘积也是1个向量,得到它的方式是模相乘,幅角相加。  

<pre>模(z1*z2)=模(z1)*模（z2)
幅角(z1*z2)=幅角(z1)+幅角(z2)
</pre>

在设计1个这样的系统时,我们将沿用在2.1.1节设计有理数包时所采用的同样的数据抽象策略,假定所有复数运算的实现都基于如下4个选择函数:real-part、imag-part、magnitude-part和angle,还要假定有2个构造复数的过程:make-from-real-imag返回1个采用实部和虚部描述的复数。make-from-mag-ang返回1个采用模和幅角描述的复数。这个过程的性质,对于任何复数z,下面2者:

```
(make-from-real-imag (real-part z)(imag-part z))
(make-from-mag-ang (magnitude z)(angle z))
```

产生出的复数都等于z.

利用这些构造函数和选择函数,我们就可以实现复数算术了,其中使用由这些构造函数和选择函数所刻画的抽象数据,就像前面在2.1.1节中针对有理数所做的那样。  

```
(define (add-complex z1 z2)
 (make-from-real-imag (+ (real-part z1)(real-part z2))
                      (+ (imag-part z1)(imag-part z2))))

(define (sub-complex z1 z2)
 (make-from-real-imag (- (real-part z1)(real-part z2))
                      (- (imag-part z1)(imag-part z2))))

(define (mul-complex z1 z2)
 (make-from-real-imag (* (real-part z1)(real-part z2))
                      (* (imag-part z1)(imag-part z2))))

(define (div-complex z1 z2)
 (make-from-real-imag (/ (real-part z1)(real-part z2))
                      (/ (imag-part z1)(imag-part z2))))                                                        
```

###带标志数据###
认识数据抽象的1种方式是将其看作最小允诺原则的1个应用。  
为了能对带标志数据进行各种操作,我们将假定有过程type-tag和contents,它们分别从数据对象中提取类型标志和实际内容(对于复数的情况,其中的极坐标或者直角坐标)。还要假定有1个过程attach-tag,它以1个标志和实际内容为参数,生成出1个带标志的数据对象。实现这些的直接方式就是采用普通的表结构:

```
(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum--TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum--CONTENTS" datum)))
```

利用这些过程,我们就可以定义出谓语rectangular?和polar?,它们分别辨识直角坐标的和极坐标的复数。  
因为每个数据对象都以其类型作为标志,选择函数就能够在不同的数据上以1种通用的方法操作。也就是说,每个选择函数的定义行为依赖于它操作它操作其上的特定的数据类型。请注意这里建立不同表示之间的界面的一般性机制:在1种给定的表示实现中,复数是1种无类型的对偶(模、幅角)。当通用型选择函数对1个polar类型的复数进行操作时,它会剥去标志并将相应内容传递给Alyssa的代码。与此相对应,当Alyssa去构造1个供一般性使用的复数时,她也为其加上类型标志,这种数据对象可以为高层过程所识别。
###数据导向的程序设计和可加性###
检查1个数据项的类型,并据此去调用某个适当过程称为基于类型的分派。在系统设计中,这是1种获得模块性的强有力策略。第1个弱点,其中的这些通用型界面过程(real-part、img-part、magnitude和angle)必须知道所有的不同表示。举例来说,假定现在希望能为前面的复数系统增加另1种表示,我们就必须将这一新表示方式标识为1种新类型,而且要在每个通用界面过程里增加1个子句,检查这一新类型,并对这种表示形式使用适当的选择函数。  
这一技术还有另1个弱点,即使这些独立的表示形式可以分别设计,我们也必须保证在整个系统里不存在2个名字相同的过程。  
位于这2个弱点之下的基础问题是,上面这种实现通用型界面的技术不具有可加性。在每次增加1种新表示形式时,实现通用选择函数的人都必须修改它们的过程,而那些做独立表示的界面的人也必须修改其代码,以避免名字冲突问题。在做这些事情时,所有修改都必须直接对代码去做,而且必须准确无误。  
现在我们需要的是一种能够将系统设计进一步模块化的方法,1种称为数据导向的程序设计的编程技术提供了这种能力。为了理解数据导向的程序设计如何工作,我们首先应该看到,在需要处理的是针对不同类型的一集公共通用型操作时,事实上,我们正是在处理1个二维表格,其中的1个维上包含着所有的可能操作,另1个维就是所有的可能类型。表格中的项目是一些过程,它们针对作为参数的每个类型实现每1个操作.在前一节中开发的复数系统里,操作名字、数据类型和实际过程之间的对应关系散步在各个通用界面过程的各个条件子句里,我们也可以将同样的信息组织为1个表格,如图2-22所示。  
数据导向的程序设计就是1种使程序能直接利用这种表格工作的程序设计技术。
###消息传递###
在数据导向的程序设计里,最关键的想法就是通过显式处理操作-类型表格的方式,管理程序中的各种通用型操作。我们在2.4.2节所用的程序设计风格,是1种基于类型进行分派的组织方式,其中让每个操作管理自己的分派。从效果上看,这种方式是将操作-类型表格分解为1行1行,每个通用型过程表示表格的1行。  
另1种实现策略是将这一表格按列进行分解,不是采用一批智能操作去基于数据类型进行分派,而是采用智能数据对象,让它们基于操作名完成所需的分派工作。如果我们想这么做,所需要做的就是做出一种安排,将每1个数据对象(例如1个采用直角坐标表示的复数)表示为1个过程。它以操作的名字作为输入,能够去执行指定的操作。按照这种方式,make-from-real-imag应该写成下面样子:

```
(define (make-from-real-imag x y)
  (define (dispatch op)
   (cond ((eq? op 'real-part) x)
         ((eq? op 'imag-part) y)
         ((eq? op 'magnitude)
          (sqrt (+ (square x) (square y))))
         ((eq? op 'angle)(atan y x))
          (else
          (error "Unknown op--MAKE-FROM-REAL-IMAG" op))))
          dispatch)
```

与之对应的apply-generic过程应该对其参数应用于1个通用型操作,此时它只需要简单地将操作名馈入该数据对象,并让那个对象去完成工作:

```
(define (apply-generic op arg)(arg op))
```

请注意,make-from-real-imag返回的值是1个过程——它内部的dispatch过程。这也就是当apply-generic要求执行1个操作时所调用的过程。  
这种风格的程序设计称为消息传递,这一名字源自将数据对象设想为1个实体,它以消息的方式接收到所需操作的名字。  
消息传递并不是1种数学机巧,而是1种有价值的技术,可以用于组织带有通用型操作的系统。
##带有通用性操作的系统##
图2-23展示了我们将要构造的系统的结构,从某些使用数值的人的观点看,在这里只存在1个过程add,无论提供给它的数是什么。add是通用型界面的1部分,这一节面将使那些使用数的程序能以1种统一的方式,访问相互分离的常规算术、有理数算术和复数算术程序包。任何独立的算术程序包(例如复数包)本身也可能通过通用型过程(例如add-complex)访问,它也可能由针对不同表示形式设计的包(直角坐标表示和极坐标表示)组合而成。进一步说,这一系统具有可加性,这样人们还可以设计出其他独立的算术包,并将其组合到这一通用型的算术系统中。
###通用性算数运算###
设计通用型算术运算的工作类似于设计通用型复数运算,我们希望(例如)有1个通用型的加法过程add,对于常规的数,它的行为就像常规的基本加法+,对于有理数,它就像add-rat,对于复数就像add-complex.我们可以沿用在2.4.3节为实现复数上的通用选择函数所用的同样策略,去实现add和其他通用算数运算。下面将为每种数附着一个类型标志,以便通用型过程能够根据其参数的类型完成到某个适用的程序包的分派。  
通用型算术过程的定义如下:

```
(define (add x y)(apply-generic 'add x y))
(define (sub x y)(apply-generic 'sub x y))
(define (mul x y)(apply-generic 'mul x y))
(define (div x y)(apply-generic 'div x y))
```

在复数包之外的程序可以从实部和虚部除法构造复数,也可以从模和幅角出发。  
这里描述的是1个具有2层标志的系统。1个典型的复数如直角坐标表示的3+4i,现在的表示形式如图2-24表示.外层标志(complex)用于将这个数引导到复数包,一旦进入复数包,下1个标志(rectangular)就会引导这个数进入直角坐标表示包。当1个复杂系统里可能有许多层次,每层与下一层次之间的连接都借助于1些通用型操作。当一个数据对象被向下传输时,用于引导它进入适当程序包的最外层标志被剥除(通过使用contents),下一层次的标志(如果有的话)变成可见的,并将被用于下1次分派。
###不同类型数据的组合###
处理跨类型操作的1种方式,就是为每1种类型组合的合法运算设计1个特定过程。例如,我们可以扩充复数包,使它能提供1个过程用于加1个复数和1个常规的数,并用标志(complex scheme-number)将它安装到表格里。

```
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x) (imag-part z)))

(put 'add '(complex scheme-number)
  (lambda (z x)(tag (add-complex-to-schemenum z x))))
```

这一技术确实可以用,但也非常麻烦。对于这样的1个系统,引进1个新类型的代价就不仅仅需要构造出针对这一类型的所有过程的包,还需要构造并安装所有实现跨类型操作的过程。
###强制###
最一般的情况就是需要处理针对1批完全无关的类型的一批完全不关的操作,直接实现跨类型操作很可能就是解决问题的最好方式了。不同的数据类型通常不是完全相互无关的,常常存在一些方式,使我们可以把一种类型的对象看作另1种类型的对象,这种过程就称为强制。举例来说,如果现在需要做常规数值与复数的混合算术,我们就可以将常规数值看成是虚部为0的复数。这样就把问题转换为2个复数的运算问题,可以由复数包以正常的方式处理了。  
一般而言,要实现这一想法,我们可以设计出一些强制过程,它们能把一些类型的对象转换到另1类型的等价对象。下面是1个典型的强制过程,它将给定的常规数值转换为1个复数,其中的实部为原来的数而虚部是0:

```
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
```

我们将这些强制过程安装到1个特殊的强制表格中,用2个类型的名字作为索引:

```
(put-coercion 'scheme-number 'complex scheme-number->complex)
```

一旦将上述转换表格装配好,我们就可以修改2.4.3节的apply-generic过程,得到1个处理强制的统一方法。在要求应用1个操作时,我们将首先检查是否存在针对实际参数类型的操作定义,就像前面一样。如果存在,那么就将任务分配到由操作-类型表格中找出的相应过程去,否则就去做强制。  
为了简化讨论,这里只考虑2个参数的情况,我们检查强制表格,查看其中的第1个参数类型的对象能否转换到第2个参数的类型。如果可以,那就对第1个参数做强制后再试验操作。如果第1个参数类型的对象不能强制到第2个类型,那么就试验另1种方式,看看能否从第2个参数的类型转换到第1个参数的类型。最后,如果不存在从1个类型到另1个类型的强制,那么就只能放弃了。下面是这个过程:

```
(define (apply-generic op .args)
  (let ((type-tags (map-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (if (= (length args) 2)
            (let ((type1 (car type-tags))
                 (type2 (cadr type-tags))
                 (a1 (car args))
                 (a2 (cadr ages)))
            (let ((t1->t2 (get-coercion type1 type2))
                 (t2->t1 (get-coercion type2 type1)))
             (cond (t1->t2
                 (apply-generic op (t1->t2 al) a2))
                 (t2->t1
                   (apply-generic op a1 (t2->t1 a2)))
                   (else
                   (error "No method for these types"
                      (list op type-tags))))))
        (error "No method for these types"
             (list op type-tags))))))
```

与显式定义的跨类型操作相比,这种强制模式有许多优越性。就像在上面已经说过的。
###类型的层次结构###
上面给出的强制模式,依赖于一对对类型之间存在着某种自然的关系。在实际中,还常常存在着不同类型之间相互关系的更全局性的结构。例如,假定我们还想构造出1个通用型的算术系统,处理整数、有理数、实数、复数。在这样的1个系统里,1种很自然的做法是把整数看作是1类特殊的有理数,而有理数又是1类特殊的实数,实数转而又是1类特殊的复数。这样,我们实际有的就是1个所谓的类型的层次结构。在其中,例如整数是有理数的子类型(也就是说,任何可以应用于有理数的操作都可以应用于整数)。与此相对应,人们也说有理数形成了整数的1个超类型。在这个例子里所看到的类型层次结构是最简单的1个,其中1个类型只能至多1个超类型和至多1个子类型,这样的结构称为1个类型塔。我怎么觉得那么像面向对象的类继承。  
如果我们面对的是1个塔类型,那么将1个新类型加入层次结构的问题就可能极大地简化了,因为需要做的所有事情,也就是刻画清楚这一新类型将如何嵌入正好位于它之上的超类型,以及它如何作为下面1个类型的超类型。  
类型塔的另1优点,在于使我们很容易实现1种概念,每个类型能够继承其超类型中定义的所有操作。与其他层次结构相比,塔形结构的另1优点是它使我们有1种简单的方法去下降一个数据对象,使之达到最简单的表示形式。
###层次结构的不足###
从这个图里可以看出,一般而言,1个类型可能有多于1个子类型,例如三角形和四边形都是多边形的子类型。此外,1个类型也可能有多于1个超类型,例如等腰直角三角形可以看作是等腰三角形,又可以看作是直角三角形。这种存在多重超类型的问题特别令人棘手,因为这就意味着,并不存在1种唯一方式在层次结构中去提升1个类型。