模块、对象和状态.md
有一种非常强有力的设计策略,特别适合用于构造那类模拟真实物理系统的程序,那就是基于被模拟系统的结构去设计程序的结构。对于有关的物理系统里的每个对象,我们构造起1个与之对应的计算对象,对该系统里的每种活动,我们在自己的计算系统里定义1种符号操作。采用这一策略时的希望是,在需要针对系统中的新对象或者新活动扩充对应的计算模型时,我们能够不必对程序做全面的修改,而只需要加入与这些对象或者动作相对应的新的符号对象。如果我们在系统的组织方面做的很成功,那么在需要添加新特征或者排除旧东西里的错误时,就只需在系统里的一些小局部中工作。  
这样,在很多程度上,组织大型程序的方式会受到我们对应被模拟系统的认识的支配。在这一章里,我们要研究2个特点很鲜明的组织策略,它们源自对于系统结构的2种非常不同的世界观。第1种策略将注意力集中在对象上,将1个大型系统看成1大批对象,它们的行为可能随着时间的进展而不断变化。另1种组织策略将注意力集中在流过系统的信息流上,非常像电子工程师观察1个信号处理系统。  
基于对象的途径和基于流处理的途径,都对程序设计提出了具有重要意义的语言要求。对于对象途径而言,我们必须关注计算对象可以怎样变化而同时保持其标识。这将迫使我们抛弃老的计算的代换模型,转向更机械式的,理论上也更不容易把握的计算的环境模型。  
在处理对象、变化和标识时,各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序并发执行的可能性,事情就会变得更困难许多。流方式特别能够用于松解在我们的模型中对时间的模拟与计算机求值过程中的各种事件发送的顺序。我们将通过1种称为延时求值的技术做到这一点。
##赋值和局部状态##
我们关于世界的常规观点之一,就是把它看作聚集在一起的许多独立对象,每个对象都有自己的随着时间变化的状态。所谓1个对象有状态,也就是说它的行为收到它的历史的影响。例如,1个银行账户就具有状态,对问题我能取出100块钱吗的回答依赖于它的存入和支取的交易历史。我们可以用1个或几个状态变量刻画1个对象的状态,在它们之中维持着有关这一对象的历史,即能够确定该对象当前行为的充分的信息。在1个简单的银行系统里,而不必记住这个账户的全部交易历史。  
在1个由许多对象组成的系统里,其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用,影响其他对象的状态。所谓交互就是建立起1个对象的状态变量与其他对象的状态变量之间的联系。确实,如果1个系统中的状态变量可以分组,形成一些内部紧密结合的子系统,每个子系统与其他子系统之间只存在松散联系,此时将这个系统看作是由一些独立对象组成的观点就会特别有用。  
对于1个系统的这种观点,有可能称为组织这一系统的计算模型的有力框架。要使这样的1个模型称为模块化的就要求它能分解为一批计算对象,使他们把能够模拟系统里的实际对象。每1个计算对象必须有它自己的一些局部状态变量,用于描述实际对象的状态。由于被模拟系统里的对象的状态是随着时间变化的,与它们相对应的计算对象的状态也必须变化。  
如果我们确定了要通过计算机里的时间顺序去模拟实际系统里时间的流逝,那么我们就必须构造出一些计算对象,使它们的行为随着程序的运行而改变。特别是,如果我们希望通过程序设计语言里常规的符号名字去模拟状态变量,那么语言里就必须提供1个赋值运算符,使我们能用它去改变与1个名字相关联的值。  
###局部状态变量###
为了说清楚这里所说的让1个计算对象具有随着时间变化的状态的意思,现在让我们来对从1个银行账户支取现金的情况做1个模拟。我们将用1个过程withdraw完成此事,它有1个参数amount表示支取的现金量。如果对应于给定的支取额,在相应的账户里尚有足够的余额,那么withdraw就返回支取之后账户里剩余的款额,否则withdraw就返回消息Insufficient funds(金额不足)。举例说,假定开始时账户里有100块钱,在不断使用withdraw的过程中我们可能得到下面的响应序列:

```
(withdraw 25)         ->75
(withdraw 25)         ->50
(withdraw 60)         ->"Insufficient funds"
(withdraw 15)         ->35
```

在这里可以看到表达式`(withdraw 25)`被求值了2次,但它产生的值却不同。这是过程的1种新的行为方式。到现在为止,我们看到的所有过程都可以看作一些可计算的数学函数的描述,对1个过程的调用将计算出相应函数作用于给定参数应得到的值,用同样的实际参数2次调用同1个过程,总会产生出相同的结果。  
为了实现withdraw,我们可以用1个变量balance表示账户里的现金余额,并将withdraw定义为1个访问balance的过程。过程withdraw检查是否balance的值至少如amount所需的那么多,如果是,withdraw就从balance里减去amount并返回balance的新值,否则withdraw就返回消息Insufficient funds.下面balance和withdraw的定义:

```
(define balance 100)
(define (withdraw amount)
 (if (>= balance amount)
     （begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
```

减少balance的工作由下面表达式完成:

```
(set! <name><new-value>)
```

这里的`<name>`应是1个符号,`<new-value>`是任何表达式。set!将修改`<name>`,使它的值变成求值`<new-value>`得到的结果。在上面例子里,我们改变了balance的值,使它的新值等于从balance的原有值中减去amount后的结果。  
在过程withdraw里还使用了begin特殊形式,用于描述对2个表达式的求值,在if的检测为真时首先减少balance的值,最后又返回balance的值。一般而言,对下面表达式的求值:

```
(begin <exp1><exp2>...<expN>)
```

将导致表达式`<exp1>`到`<expk>`按顺序求值,最后1个表达式`<expN>`的值又将作为整个begin的形式的值返回。  

按照上面的描述,balance是定义在全局环境里的1个名字,因此完全可以自由地被任何过程检查或者修改。如果我们能将balance做成为withdraw内部的东西,情况就会好得多,因此这将使withdraw成为唯一能自己访问balance的过程,任何其他过程都只能间接地访问balance。我们可以通过下面方式重写出withdraw,使balance成为它内部的东西:

```
(define new-withdraw
  (let ((balance 100))
   （lambda （amount)
     （if (>= balance amount)
      (begin (set! balance (- balance amount))
              balance)
      "Insufficient funds"))))
```

这样的做法是用let创建1个包含局部变量balance的环境,并使它约束到初始值100.在这个局部环境里,我们用lambda创建1个过程,它以amount作为1个参数,其行为就像是前面withdraw的过程,通过对表达式的求值结果返回的过程就是new-withdraw,它的行为就像是withdraw,但其中的变量却是任何其他过程都不能访问的。  
下面我们还可以创建出除了提款还能够存入款项的对象,这样就可以表示简单的银行账户了。下面是1个过程,它返回1个具有给定初始余额的银行账户对象:

```
(define (make-account balance)
  (define (withdraw amount)
   （if (>= balance amount)
      (begin (set! balance (- balance amount))
              balance)
      "Insufficient funds"))
    (define (deposit amount)
     (set! balance (+ balance amount))
      balance)
    (define (deposit m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request--MAKE-ACCOUNT"
            m)))))
    dispatch)
```

对于make-account的每次调用将设置好1个带有局部状态变量balance的环境,在这个环境里,make-account定义了能够访问balance的过程deposit和withdraw,另外还有1个过程dispatch,它以1个消息作为输入,返回这2个局部过程之一。过程dispatch本身将被返回,作为表示有关银行账户对象的值。  
过程make-account可以像下面这样使用:

```
(define acc (make-account 100))
((acc 'withdraw 50))        ->50
((acc 'withdraw 60))        ->Insufficient funds
((acc 'deposit) 40)         ->90
((acc 'withdraw 60))        ->30
```

对acc的每次调用将返回局部定义的deposit或者withdraw过程,这个过程随后被应用于给定的amount,就像make-withdraw一样,对make-account的另1次调用:

```
(define acc2 (make-account 100))
```

将产生出另1个完全独立的账户对象,维持着它自己的局部balance。
###引进赋值带来的利益###
由上面蒙特卡罗方法实例展示出的1种具有普遍性的现象是,从1个复杂计算过程中1部分的观点看,其他部分都像是在随着时间不断变化,它们隐藏起自己的随时间变化的内部状态。假设我们希望写出1个计算机程序,反应这种系统分解,那么就需要让计算对象的行为随着时间变化,用局部状态变量去模拟系统的状态,用对这些变量的赋值去模拟状态的变化。
###引进赋值的代价###
只要我们不使用赋值,以同样参数对同1个过程的2次求值一定产生出同样的结果,因此就可以认为过程是在计算数学函数。像我们在本书的前2章中所做的那样,不用任何赋值的程序设计称为函数式程序设计。  
这里的麻烦在于,从本质上说,代换的最终基础就是,这一语言里的符号不过是作为值的名字。而一旦引入了set!和变量的值可以变化的想法,1个变量就不再是1个简单的名字了。现在的1个变量索引着1个可以保存值的位置,而存储在那里的值也是可以改变的。
###同一和变化###
假定我们用同样的参数调用make-decrementer两次,就会创建出2个过程:

```
(define D1 (make-decrement 25))
(define D2 (make-decrement 25))
```

D1和D2是同一的吗?"是"是1个可以接受的回答,因为D1和D2具有同样的计算行为,都是同样的将会从其输入里减去25的过程。事实上,我们确实可以在任何计算中用D1代替D2而不会改变结果。  
如果1个语言支持在表达式里同一的东西可以相互替换的改变,这样替换不会改变有关表达式的值,这个语言就称为具有引用透明性。在我们的计算机语言里包含鳄梨set!之后,也就打破了引用透明性,就使确定能够通过等价的表达式代换去简化表达式变成了1个异常错综复杂的问题。  
一般而言,我们只能用如下方式确定2个看起来同一的事物是否确实是同1个东西,改变其中的1个对象,去看另1个对象是否也同样改变。但是,如果不能通过观察同1个对象2次,看看一次观察中看到的某些对象性质与另1次不同。
###命令式程序设计的缺陷###
与函数式程序设计相对应的,广泛采用赋值的程序设计被称为命令式程序设计。除了会导致计算模型的复杂性之外,以命令式风格写出的程序还很容易出现一些不会在函数式程序中出现的错误。

```
(define (factorial n)
  (define (iter product counter)
   (if (> counter n)
    product
    (iter (* counter product)
          (+ counter 1))))
   (iter 1 1))
```

我们也可以不通过内部迭代循环传递参数,而是采用更命令式的风格,显式地通过赋值去更新变量product和counter的值:

```
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 （set! counter (+ counter 1))
                 （iter))))
        (iter)))
```

这样做不会改变程序产生的结果,但却会引入1个很微妙的陷阱。我们应该如何确定2个赋值的顺序呢?像上面那样写出的程序是正确的,但如果以相反顺序写这2个赋值:

```
(set! counter (+ counter 1))
(set! product (* counter product))
```

就会产生出上面不同的错误结果。一般而言,带有赋值的程序将强迫人们去考虑赋值的相对顺序,以保证每个语句所用的是被修改变量的正确版本。在函数式程序设计中,这类问题根本就不会出现。
##求值的环境模型##
由于赋值的存在,变量已经不能看作仅仅是某个值的名字。此时的1个变量必须以某种形式执行了1个位置,相应的值可以存储在那里。在我们的新求值模型里,这种位置将维持在称为环境的结构中。  
1个环境就是框架的1个序列,每个框架是包含着一些约束的1个表格(可能为空),这些约束将一些变量名字关联于对应的值(在1个框架里,任何变量至多只能有1个约束)。每个框架还包含着一个指针,指向这一框架的外围环境。如果由于当前讨论的目的,将相应的框架看作是全局的,那么它将没有外围环境。1个变量相对于某个特定环境的值,也就是在这一环境中,包含着该变量的第1个框架里这个变量的约束值。如果在序列中并不存在这一变量的约束,那么就说这个变量在该特定环境中是无约束的。  
图3-1展示了1个简单的环境结构,其中包含了3个框架,分别用I、II、III标记。在这个图中,A、B、C和D都是环境指针,其中C和D指向同1个环境。变量z和x在框架II里约束,而变量y和x在框架I里约束。x在环境D里的值是3,x相对于环境B的值也是3.后一情况应按如下方式确定:我们首先检查序列中的第1个框架(框架III),在这里没有找到x的约束,因此继续前往到外围环境D并在框架I里找到了相应的约束。在另一方面,x在环境A中的值就是7,因为序列中的第1个框架(框架II)里包含x和7的约束.相对于环境A,我们说在框架II里x与7的约束遮蔽了框架I里x与3的约束。  
环境对于求值过程是至关重要的,因为它确定了表达式求值的上下文。实际上,我们完全可以说,在1个程序语言里的1个表达式本身根本没有任何意义。即使像(+ 1 1)这样极其简单的表达式,其解释也要依赖于有关的操作是在某个上下文里进行的,在那里+是表示加法的符号,这样在现在讨论的求值模型中,我们将总说某个表达式相对于某个环境的求值。为了描述与解释器的交互作用,我们始终假定存在1个全局环境,它只包含着1个框架(没有外围环境),这个环境里包含着所有关联于基本过程的符号的值。
###求值规则###
在求值的环境模型里,1个过程总是1个对偶,由一些代码和1个指向环境的指针组成。过程只能通过1种方式创建,那就是通过求值1个lambda表达式,这样产生出的过程的代码来自这一lambda表达式的正文,其环境就是求值这个lambda表达式,产生出这个过程时的那个环境。举个例子,考虑在全局环境里求值下面的过程定义:

```
(define (square x)
 (* x x))
```

过程定义的语法形式,不过是作为其基础的隐含lambda表达式的语法糖衣,上面的定义就像是写成下面等价的表示:

```
(define square
 (lambda (x) (* x x)))
```

其中求值(lambda (x)(* x x)),并将符号square约束于这一求值得到的结构,这些都是在全局环境中完成的。  
图3-2展示的是求值这一define表达式的结果,这里的过程对象是1个序对,其代码部分描述的是1个带有1个形式参数x的过程,过程体是(* x x).过程对象的环境部分是1个指向全局环境的指针,因为产生这个过程的lambda表达式是在全局环境中求值的。这个定义在全局框架中加入了1个新约束,将上述过程对象约束于符号square。一般而言,define建立定义的方式就是将新的约束加入框架里。  
我们已经看到了创建过程的有关情况,现在就可以描述过程的应用了。环境模型说明:在将1个过程应用于一组实际参数时,将会建立起1个新环境,其中包含了将所有形式参数约束于对应的实际参数的框架,该框架的外围环境就是所用的那个过程的环境。随后就在这个新环境之下求值过程的体。  
为了让演示这一规则的实施情况,图3-3展示了通过在全局环境里对表达式(square 5)求值而创建的环境结构。其中的square是图3-2里生成的过程,这一过程应用的结果是创建1个新环境,在图中标记为E1.这个环境从1个框架开始,框架里包含着将这个过程的形式参数约束到实际参数5.从这一框架引出的指针说明这个框架的外围环境就是全局环境。在这个地方之所以选择全局环境,是因为它就是作为square过程对象的1部分的那个环境。现在我们要在E1里求值过程的体`(* x x)`.因为在E1里的x的值是5,所以求值结果是`(* 5 5)`,也就是25.  
我们可以把过程应用的环境模型总结为下面2条规则:

- 将1个过程对象应用于1集实际参数,将构造出1个新框架,其中将过程的形式参数约束到调用时的实际参数,而后在构造起的这一新环境的上下文中求值过程体。这个新框架的外围环境就是作为被应用的那个过程对象的1部分环境。
- 相对于1个给定环境求值1个lambda表达式,将创建起1个过程对象,这个过程对象是1个序对,由该lambda表达式的正文和1个指向环境的指针组成,这一指针的就是创建这个过程对象时的环境。

我们也已经说明了,用define定义1个符号,也就是在当前环境框架里建立1个约束,并赋予这个符号指定的值。最后让我们来说明set!的行为方式,因为一开始就是因为这个操作的存在,迫使我们引进上述的环境模型。在某个环境里求值表达式`(set! <variable><value>)`,要求我们首先在环境中确定有关变量的约束位置,而后修改这个约束,使之表示这个新值。这也就说,首先需要找到包含这个变量的约束的第1个框架,而后修改这一框架。如果该变量在环境中没有约束,set!将报告1个错误。  
###简单过程的应用###
在1.1.5节介绍代换模型时,我们展示了有下面的过程定义之后,组合式(f 5)怎样求值得到136:

```
(define (square x)
 (* x x))

(define (sum-of-square x y)
 (+ (square x)(square y)))

(define (f a)
 (sum-of-square (+ a 1)(* a 2)))
```

现在我们用环境模型来分析同1个实例。图3-4展示了在全局环境里对f、square和sum-of-squares定义求值后创建起的3个过程对象,每个过程对象都由一些代码和1个指向全局环境的指针组成。  
在图3-5里,我们看到的是由对(f 5)的求值创建起的环境结构。对于f的调用创建了1个新环境E1,它开始于1个框架,其中f的形式参数a被约束到实参5.我们需要在E1里求值f的体:

```
(sum-of-squares (+ a 1)(* a 2))
```

在求值这个组合式时,首先需要求值其中的子表达式。第1个子表达式sum-of-squares以1个过程对象为值(请注意看这个值是如何找到的:首先在E1的第1个框架中找,这里没有包含sum-of-squares的约束。而后进入有关的外围环境,即全局环境,并在那里找到了图3-4所示的约束)。对另外2个表达式的求值是应用2个基本运算符+和*,通过求值组合式(+ a 1)和`(* a 2)`分别得到6和10.  
现在需要把过程对象sum-of-squares应用于实参6和10,这时得到的是1个新环境E2,形式参数x和y在其中约束于对应的实际参数。现在要做的就是在E2里求值组合式(+ (square x)(square y)).这进一步要求我们求值(square x),其中的square从全局环境中找到,而x是6.我们又需要设定另1个新环境E3,其中将x约束到6,并在这里求值square的体`(* x x)`.作为sum-of-squares应用的另一部分,我们还必须求值子表达式(square y),其中的y是10.这是对square的第2个调用,它创建起另1个环境E4，其中square的形式参数x约束到10,我们必须在E4里求值`(* x x)`.  
各个子表达式求值后返回得到的值,对square的2个调用产生的值被sum-of-squares加起来,作为求值的结果返回,因为我们在这里关心的是环境结构,因此将不详细考察这些返回值如何在调用之间传递的问题。
###将框架看作局部状态的展台###
现在可以从环境模型出发,看看可以怎样用过程和赋值表示带有局部状态的对象。作为1个例子,还是考虑取自3.1.1节的由调用下面过程创建的提款处理器:

```
(define (make-withdraw balance)
  (lambda (amount)
   (if (>= balance amount)
       (begin (set! balance (- balance amount))
              balance)
      "Insufficient funds")))
```

让我们仔细看看下式的求值:

```
(define w1 (make-withdraw 100))
```

而后做:

```
(w1 50)          ->50
```

图3-6展示了在全局环境里定义make-withdraw过程的结果。这一求值产生出1个过程对象,其中包含着1个指向全局环境的指针。到目前为止,在这个实例里还没有出现任何与前面看过的实例不同的东西,除了过程体本身也是1个lambda表达式之外。  
计算中的有趣现象出现在将过程make-withdraw应用于1个参数的时候：

```
(define w1 (make-withdraw 100))
```

与平常一样,我们在开始时设置了环境E1,其中将形式参数balance约束到实参100,并在这一环境里求值make-withdraw的体,也就是那个lambda表达式。这一求值构造起1个新过程对象,其代码由这个lambda描述,而它的环境就是E1,也就是求值这个lambda生成该过程对象时的那个环境。这样做的过程对象被作为调用make-withdraw的返回值,在全局环境里约束于W1,因为这个define本身的求值是在全局环境里进行的。图3-7显示出这样做的结果得到的环境结构。  
现在让我们来分析W1应用于1个参数时发送的情况:

```
(w1 50)         ->50
```

此时首先要构造出1个框架,W1的形式参数amount在其中约束到实参50,需要注意的最关键一点是,这个框架的外围环境并不是全局环境,而是环境E1,因为它是由过程对象W1所指定的环境。现在,我们需要在这个新环境里求值下面的过程体:

```
(if (>= balance amount)
    (begin (set! balance (- balance amount))
    balance)
    "Insufficient funds")
```

这样做得到的环境结构如图3-8所示,在被求值的表达式里引用了amount和balance,其中的amount在环境里的第1个框架里找到,而balance则沿着外围环境指针向前在E1里找到。  
在执行set!时,位于E1里balance的约束就被修改了。对W1的调用完成时,balance是50,而包含着这个balance的框架仍由过程对象W1指着。约束amount的那个框架(我们曾经在其中执行了修改balance代码)现在已经无关重要了,因为构造它的过程已经结束,环境中的任何1部分都不再包含指向这个框架的指针。  
在下次W1被调用时,这一过程又会造起另1个新框架,其中建立起amount的1个新约束,这一框架的外围环境还是E1。根据上面的分析,我们可以看到E1怎样起保存过程对象的局部状态变量的位置的作用。图3-9展示的是调用w1之后的情景。  
现在来看看通过再次调用make-withdraw,创建起第2个提款对象的情况:

```
(define w2 (make-wthdraw 100))
```

这样做产生的环境结构如图3-10所示,其中显示了W2是另1个过程对象,也就是说,是一些代码和1个环境的序对.通过调用make-withdraw为W2创建起的环境是E2,它包含了1个框架,其中包含着它自己的对balance的局部约束。在另一方面,W1和W2具有相同的代码,也就是在make-withdraw体内的那个lambda表达式所确定的代码。我们从这里就可以看到,为什么W1和W2在行为上完全是相互独立的对象。对W1的调用引用的保存在E1里的状态变量balance,而对W2的调用引用的是E2里的balance。这样,修改1个对象的局部状态当然不会影响到另1个对象。
###内部定义###
1.1.8节介绍了过程可以有内部定义的思想,这样就引入了块结构,就像下面计算平方根的过程里的情况:

```
(define (sqrt x)
 (define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.01))
 (define (improve guess)
  (average guess (/ x guess)))
 (define (sqrt-iter guess)
  (if (good-enough? guess)
   guess
   (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
```

现在,我们就可以利用上面介绍的环境模型,去考察为什么这些内部定义具有所需要的行为。图3-11所示的是在表达式(sqrt 2)求值中的1点。在那里,内部过程good-enough?被第1次调用,其中的guess等于1.  
请注意此时的环境结构。sqrt是全局环境里的1个符号,它被约束到1个过程对象,与之关联的环境就是全局环境。在sqrt被调用时,形成了1个新的环境E1，它将成为全局环境的下属。这里,参数x约束到2,而后在E1里求值sqrt的体。由于sqrt体中的第1个表达式是:

```
(define (good-enough? guess)
  (< (abs (- (square guess) x))0.001))
```

对这一表达式的求值在环境E1里定义出过程good-enough?.说的更准确一些,符号good-enough?被加入E1的第1个框架里,并被约束于1个过程对象,其关联环境是E1.与此类似,improve和sqrt-iter也在E1里定义为过程。  
在定义好各个局部过程之后,表达式(sqrt-iter 1.0)被求值,还是在环境E1里。因此,调用在E1里约束于sqrt-iter的过程对象时,我们以1作为实际参数,这一调用创建了另1个环境E2，在其中sqrt-iter的形参guess被约束到1.sqrt-iter转而以guess的值作为实际参数调用good-enough?,这就建立了另1个环境E3,在这个环境里,guess被约束到1.  
虽然sqrt-iter和good-enough?里都有名字为guess的形参,但它们是2个不同的局部参数,位于不同的框架里。还有,E2和E3都以E1作为其外围环境,这是因为过程sqrt-iter和good-enough?都以E1作为自己的环境部分。这种情况造成的1个后果就是,出现在good-enough?体内部的符号x将引用出现在E1里的x约束,也就是原来sqrt被调用时的那个x的值。这样,环境模型已经解释清楚了以局部过程定义作为程序模块化的有用技术中的2个关键性质:

- 局部过程的名字不会与包容它们的过程之外的名字相互干扰,这是因为这些局部过程名都是在该过程运行时创建的框架里面约束的,而不是在全局环境里约束的。
- 局部过程只需将包含着它们的过程的形参作为自由变量,就可以访问该过程的实际参数。这是因为局部过程体的求值所在的环境是外围过程求值所在的环境的下属。

##用变动数据做模拟##
###变动的表结构###
针对序对的基本操作——cons、car和cdr,能用于构造表结构,或者选出表结构中的各个部分,但它们不能修改表结构。我们至今用过的其他表操作(例如append和list)也都是如此,因此它们都是基于cons、car和cdr定义出来。要修改表结构就需要新的操作。  
针对序对的基本改变函数是set-car!和set-cdr!.set-car!要求2个参数,其中的第1个参数必须是1个序列,set-car!修改这个序对,将它的car指针替换为指向set-car!的第2个参数的指针。  
作为1个例子,我们假定x约束到表((a b) c d),y约束到表(e f),如图3-12所示。对表达式(set-car! x y)的求值将修改x约束的那个表,将它的car用y的值取代。这一操作的结果如图3-13所示。从这个图中,我们可以看到结构x被修改了,现在它将被打印为((e f) c d).原来由被取代的指针标识的那个表示表(a b)的序对,现在已经从原来的结构中摘除了。  
我们可以对图3-13和图3-14做1个比较,图3-14展示的是执行(define z (cons y (cdr x)))的结果,其中x和y约束到图3-12表示的那样的2个表.这一求值使变量z约束到了由操作创建的1个新序对,而约束的表并没有改变。  
set-cdr!操作与set-car!类似,它们之间的差异就在于被取代的是序对的cdr指针,而不是car指针.对图3-12中的表执行(set-cdr! x y)的效果如图3-15所示。在这里,x的cdr指针被指向(e f)的指针取代。还有,原来作为x的cdr的表(c d),现在也已经从这一结构里摘掉了。  
cons通过创建新序对的方式构造新的表,而set-car!和set-cdr!则是修改现存的序对。cons可以用2个改变函数和1个过程get-new-pair实现,这个过程返回1个新序对,假定它不是任何现存表结构的组成部分。我们先取得1个序对,而后将它car和cdr的指针分别设置到指定对象,最后返回这个序对作为cons的结果。

```
(define (cons x y)
 (let ((new (get-new-pair)))
   (set-car! new x)
   (set-cdr! new y)
   new))
```

###共享和相等###
在3.1.3节里,我们提出了由于引入赋值而产生的同一和变化的理论问题,当不同的数据对象共享某些序对时,这些问题就表现到现实中来了。例如,考虑由下面求值形成的结构:

```
(define x (list 'a 'b))
(define z1 (cons x x))
```

正如图3-16所示,这里的z1是1个序列,其car和cdr都指向同1个序对x.这种z1的car和cdr共享x是cons的简单实现方式的自然结果。一般而言,用cons构造出的表结构总是序对的1个相互链接的结构,其中可能会有许多独立的序对被一些不同结构所共享。  
与图3-16不同,图3-17展示了是由下式创建出的结构:

```
(define z2 (cons (list 'a 'b (list 'a 'b))))
```

在这一结构中,2个表(a b)的各个序对互不相同,虽然其中的符号是共享的。  
作为表考虑,z1和z2表示是同1个表((a b) a b).一般来说,如果我们只用cons、car和cdr对各种表进行操作,其中的共享就不完全不会被察觉。然而,如果允许改变表结构的话,共享的情况就会显现出来了。作为考察这种共享会产生什么影响的例子,现在考虑下面的过程,它将修改被它应用的那个结构的car：

```
(define (set-to-wow! x)
(set-car! (car x) 'wow')
 x)
```

虽然z1和z2可以看作是同样的结构,将set-to-wow!应用于它们,就会产生不同的结果。对于z1而言,修改其car也同时修改了它的cdr,因为在z1里的car和cdr是同一个序对。而对于z2,由于其car和cdr是不同的,所以set-to-wow!只修改它的car:

```
z1        ->((a b) a b)
(set-to-wow! z1)
((wow b) wow b)

z2        ->((a b) a b)
(set-to-wow! z2)
((wow b) a b)
```

检查表结构是否共享的1种方式是使用谓语eq?,是作为检查2个符号是否相同的手段。  
###队列的表示###
利用改变函数set-car!和set-cdr!,我们可以用序对构造出一些单靠cons、car和cdr无法构造的数据结构,这一节将展示如何用序对表示1种称为队列的数据结构。下一节将展示如何表示称为表格的数据结构。  
1个队列是1个序列,数据项只能从1端插入(这称作队列的末端),只能从另一端删除(队列的前端)。图3-18显示的是1个初始化为空的队列,而后插入数据项a和b,而后删除a,又插入c和d,而后又删除b.由于数据项是按照它们插入的顺序删除,因为队列有时也被称为FIFO缓冲区。  
按照数据抽象的说法,队列可以看作是由下面1组操作定义的结构:

- 1个构造函数(make-queue),它返回1个空队列(不包含数据项的队列)
- 2个选择函数
- 2个改变函数

由于队列就是数据项的序列,我们当然可以将它表示1个常规的表。这样,队列的前端就是表的car，向队列中插入数据项就是将1个项附加到表的最后,而从队列里删除1个项就是取这个表的cdr.但是这种表示是相当低效的,这是因为,为了插入1个数据项,我们就必须扫描整个表,直到到达表尾。由于扫描1个表的方法只有通过执行1系列的cdr操作,对于n个项的表,这种扫描就需要做O(n)步。简单地修改一下表的表示方式,就可以克服这个缺点,使队列操作都只要O(1)步就能实现,也就是说,使所需的步数完全与队列的长度无关。  
采用表的表示形式,引出的1个问题是为了找到表尾需要扫描整个表.这里的原因就在于,表的标准表示方式是用1个序对的链,虽然这样可以很方便地提供1个表的开始指针,但却不能为我们提供访问表尾的方便方法。如果要避免这一缺陷,那就需要修改表示方式,将队列表示为1个表,并带有1个指向表的最后序对的指针。采用这种方式,如果我们需要插入1个数据项时,那就只需考察这个尾指针,因为就可以避免对表的扫描了。  
这样,队列被表示为一对指针front-ptr和rear-ptr,它们分别指向1个常规表中的第1个序对和最后1个序对。由于我们希望队列成为1个可标示对象,为此可以将这2个指针cons起来。这样,队列本身也将是2个指针的cons.图3-19显示了这种表示的情况。  
为了定义出队列的各种操作,我们将使用下面几个过程,它们可以用于选择或者修改队列的前端和末端指针。  
```
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item)(set-car! queue item))
(define (set-rear-ptr! queue item)(set-car! queue item))
```

现在我们就可以定义队列的各个实际操作了,如果1个队列的前端指针等于其末端指针,那么就认为这个队列为空。  

```
(define (empty-queue? queue)(null? (front-ptr queue)))
```

构造函数make-queue返回1个初始为空的表,也就是1个序对,其car和cdr都是空表:

```
(define (make-queue)(cons '() '()))
```

在需要选取队列前端的数据项时,我们就返回由前端指针指向的序对的car:

```
(define (front-queue queue)
 (if (empty-queue? queue)
  (error "FRONT called with an empty queue" queue)
  (car (front-ptr queue))))
```

要向队列中插入1个数据项,我们将按照图3-20中表明的方式,首先创建起1个新序对,其要向队列中插入1个数据项,其cdr是空表。如果这一队列原来是空的,那么就让队列的前端指针和后端指针都指向这个新序对。否则就修改队列中最后1个序对,使之指向这个新序对,而后让队列的后端指针也指向这个新序对。  

```
(define (insert-queue! queue item)
 (let ((new-pair (cons item '())))
  (cond ((empty-queue? queue)
       (set-front-ptr! queue new-pair)
       (set-rear-ptr! queue new-pair)
       queue)
      (else
       (set-cdr! (rear-ptr queue) new-pair)
       (set-rear-ptr! queue new-pair)
       queue))))
```

要从队列的前端删除1个数据项,我们只需要修改队列的前端指针,使它指向队列中的第2个数据项,通过队列中的第1项的cdr指针就可以找到这个项(参考图3-21).

```
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
        (error "DELETE! called with an empty queue"queue))
        (else
        set-front-ptr! queue (cdr (front-ptr queue)))
        queue))
```

###表格的表示###
我们首先考虑一维表格的问题,在这种表格里,每个值保存在1个关键码之下。我们要将这种表格实现为1个记录的表,其中的每个记录将实现为由1个关键码和1个关联值组成的序对。将这种记录连接起来构成1个序对的表,让这些序对的car指针顺序指向各个记录。这些作为连接结构的序对就成为这一表格的骨架。  
为了在向表格里加入记录时能有1个可以修改的位置,我们将这个表格构造为1种带表头单元的表。带表头单元的表在开始处有1个特殊的骨架序对,其中保存着1个哑记录——目前在这里存放1个特殊符号`*table*`.图3-22显示下面表格的盒子指针图。  
为了从表格里提取信息,我们用了1个lookup过程,它以1个关键码为参数,返回与之相关联的值(如果在这个关键码之下没有值就返回假)。lookup是基于assoc操作定义的,这一操作要求1个关键码和1个记录的表作为参数。请注意,assoc根本不去看那个哑记录,它返回以给定关键码为car的那个记录。lookup检查由assoc返回的结果记录是否为假,而后返回该记录中的值(其cdr).  

```
(define (loopup key table)
 (let ((record (assoc key (cdr table))))
  (if record
    (cdr record)
    false)))

(define (assoc key records)
  (cond ((null? records) false)
      (equal? key (caar records))(car records))
      (else (assoc key (cdr records))))
```

要在1个表格里某个特定的关键码之下插入1个值,我们首先用assoc查看该表格里是否已经有以此做为关键码的记录。如果没有就cons起这关键码和相应的值,构造出1个新记录,并将它插入到记录表的最前面,位于哑记录之后。如果表格里已经有了具有该关键码的记录,那么就将该记录的cdr设置为这个新值。表格的头单元为我们提供了1个明确的位置,使我们在插入新纪录能确定相应的修改位置。

```
(define (insert! key values table)
 (let ((record (assoc key (cdr table))))
  (if record
   (set-cdr! record value)
   (set-cdr! table 
      (cons (cons key value)(cdr table)))))
  'ok)
```

在构造1个新表格时,我们只需要创建1起1个包含符号`*table*`的表:

```
(define (make-table)
 (list *table*))
```

###两维表格###
两维表格里的每个值由2个关键码索引。我们可以将这种表格构造为1个一维表格,其中的每个关键码又标识了1个子表格。图3-23中的盒子指针图表示的是下面的表格:  
在需要查找1个数据项时,我们先用第1个关键码确定对应的子表格,后用1第2个关键码在这个子表格里确定记录。  

```
(define (loopup key-1 key-2 table)
 (let ((subtable (assoc key-1 (cdr table))))
  (if subtable
   (let ((record (assoc key-2 (cdr subtable))))
     (if record
       (cdr record)
       false))
      false)))
```

如果需要将1个新数据项插入到一对关键码之下,我们首先用assoc去查看在第1个关键码下是否存在1个子表格。如果没有,那么就构造起1个新的子表格，其中只包含1个记录(key-2,value),并将这一子表格插入到表格中的第1个关键码之下。如果表格里已经有了对应于第1个关键码的子表格,那么就将新值插入该子表格,用的就是上面所述的一维表格中插入的方法:

```
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
  (if subtable
   (let ((record (assoc key-2 (cdr subtable))))
   	(if record
        (set-cdr! record value)
	(set-cdr! subtable
		  (cons (cons key-2 value)
		  (cdr subtable)))))
    (set-cdr! table
        (cons (list key-1
	      (cons key-2 value))
	      (cdr table)))))
  'OK)
```

###创建局部表格###
上面定义的lookup和insert!操作都以表格作为1个参数,这也使我们可以将它们用到包含多个表格的程序里。处理多个表格的另1种形式是为了每个表格提供1对独立的lookup和insert!过程。为了能够这么做,我们可以用过程的方式表表示表格,将表格表示为1个以局部状态的方式维持着1个内部表格的对象。在接到1个适当的消息时,这种表格对象将提供相应的过程,实现对内部表格的各种操作。下面就是1个采用这种方式表示两位表格的生成器:

```
(define (make-table)
  (let ((local-table (list *table*)))
  (define (lookup key-1 key-2)
   (let ((subtable (assoc key-1 (cdr local-table))))
    (if subtable
     (let ((record (assoc key-2 (cdr subtable))))
      (if record
       (cdr record)
       false))
  (define (insert! key-1 key-2 value)
  (let ((subtable (assoc key-1 (cdr local-table))))
   (if subtable
    (let ((record (assoc key-2 (cdr subtable))))
     (if record
      (set-cdr! record value)
      (set-cdr! subtable
          (cons (cons key-2 value)
          (cdr subtable)))))
      (set-cdr! local-table
          (cons (list key-1
             (cons key-2 value)
            (cdr local-table)))))
      'ok)
    (define (dispatch m)
     (cond ((eq? m 'lookup-proc) lookup)
           ((eq? m 'insert-proc!) insert!)
           (else (error "Unknown operation--TABLE") m))))
           dispatch))
```

利用make-table,我们就能做出2.4.3节里为做数据导向的程序设计而用的get和put操作了。它们实现如下:

```
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
```

过程get以上2个关键码为参数,put以2个关键码和1个值为参数,这2个操作都访问同1个局部表格,这一表格被封装在由对make-table的调用创建起的对象里面。
##并发:时间是1个本质问题##
###控制并发的机制###
我们已经看到了处理并发进程的困难,这些困难的根源就在于考虑不同进程里各个事件之间相互交错的情况.举例来说,假定我们有2个进程,其中1个里面有顺序的3个事件(a,b,c),另1个有顺序的3个事件(x,y,z).如果这2个进程并发进程,对于它们的执行如何交错没有任何限制,那么就存在20种可能的事件排列,它们都与2个进程中各个事件的排列顺序相容:

<pre>(a,b,c,x,y,z)(a,x,b,y,c,z)(x,a,b,c,y,z)(x,a,y,z,b,c)
  (a,b,x,c,y,z)(a,x,b,y,z,c)(x,a,b,y,c,z)(x,y,a,b,c,z)
  (a,b,x,y,c,z)(a,x,y,b,c,z)(x,a,b,y,z,c)(x,y,a,b,z,c)
  (a,b,x,y,z,c)(a,x,y,b,z,c)(x,a,y,b,c,z)(x,y,a,z,b,c)
  (a,x,b,c,y,z)(a,x,y,z,b,c)(x,a,y,b,z,c)(x,y,z,a,b,c)
</pre>

作为设计这一系统的程序员,我们可能就必须考虑这20种排序中的每1种的效果,检查是否每种排列的行为都是可以接受的。当进程和事件的数量进一步增加时,这一方式很快就会变得无法控制了。  
另1种更实际的方法是,在设计并发系统时,设法做出一些一般性的机制,使我们可能限制并发进程之间的交错情况,以保证程序具有正确的行为方式。
####对共享变量的串行访问####
串行化就是实现下面的想法:使进程可以并发地执行,但是其中也有一些过程不能并发地执行。说的更准确些,串行化就是创建一些不同的过程集合,并且保证在每个时刻,在任何1个串行化集合里至多只有1个过程的1个执行。如果某个集合里有过程正在执行,而另一进程企图执行这个集合里的任何过程时,它就必须等待到前1过程的执行结束。  
我们可以借助串行化去控制对共享变量的访问,举例说,如果我们希望基于某个变量已有的值去更新它,那么就应该将访问这一变量的现有值和给这一变量赋新值的操作都放入同1个过程里,而后设法保证,任何能给这个变量赋值的过程都不会与这个过程并发运行,方法是将所有这样的过程都放在同1个串行化集合里。这就保证了在访问1个变量和给它赋值之间,这一变量的值不会改变。
####使用多重共享资源的复杂性####
串行化提供了1种非常强有力的抽象,能帮助我们将并发程序的复杂性孤立起来,使这个程序能够被小心地和(希望是)正确地处理。然后,如果只存在1个共享资源(例如1个银行账户),串行化的使用问题是相对比较简单的。但是如果存在着多项共享资源,并发程序设计就可能变得非常难以把握了。  
为了展示可能出现的1种困难,现在假定我们希望交换2个账户的余额。我们首先访问每个账户以确定其中的余额,而后计算出这2个余额之间的差额,从1个账户里减去这一差值,而后将它存入另1个账户。

```
(define (exchange account1 account2)
 (let ((difference (- (account1 'balance)
                      (account2 'balance))))
      ((account1 'withdraw) difference)
      ((account2 'deposit) difference)))
```

####串行化的实现####
我们将用1个更基本的称为互斥元(mutex)的同步机制来实现串行化。互斥元是1种对象,假定它提供了2个操作。  
1个互斥元可以被获取(acquired)或者释放(released).1个某个互斥元被获取,对于这一互斥元的任何其他获取操作都必须等到该互斥元被释放之后。  
在我们的实现里,每个串行化组关联着1个互斥元,给了1个过程p,串行化将返回1个过程,该过程将获取相应互斥元,而后运行p,而后释放该互斥元。这样就能保证,由这个串行化组产生的所有过程中,1次只能运行1个,这就是需要保证的串行化性质。  

```
(define (make-serializer)
  (let ((mutex (make-mutex)))
   (lambda (p)
    (define (serialized-p . args)
     (mutex '(acquire)
      (let ((val (apply p args)))
      (mutex 'release)
      val))
    serialized-p)))
```

互斥元是1个变动对象(这里将采用1个单元素的表,称它为1个单元),这个互斥元可以被获取;当值为真时该互斥元就是不可用的,任何其他获取这一互斥元的进程都必须等待。  
我们的互斥元构造函数make-mutex开始时将单元的内容初始化为假。为了获取1个互斥元,首先需要检查这个单元。如果互斥元可用,我们就将该单元设置为真并继续下去,否则就进入1个循环里等待,1次又1次地试图去获取这个互斥元,直到发现它可用为止。为释放1个互斥元,只需要将单元的内容设置为假:

```
(define (make-mutex)
 (let ((cell (list false)))
  (define (the-mutex m)
   (cond ((eq? m 'acquire)
    (if (test-and-set! cell)
        (the-mutex 'acquire)))
        ((eq? m 'release)(clear! cell))))
      the-mutex))

(define (clear! cell)
 (set-car! cell false))
```

test-and-set!检查单元并返回检查结果,除此之外,如果检查结果为假,test-and-set!在返回假之前还要将单元内容设置为真。我们可以用下述过程描述这种行为:

```
(define (test-and-set! cell)
  (if (car cell)
   true
   (begin (set-car! cell true)
   false))
```

不过,这样实现test-and-set!不能保证达到所需要的效果,因为这里有1个至关重要的细节,也就是整个系统完成并发控制的核心:test-and-set!操作必须以原子操作的方式执行。也就是说,我们必须保证,一旦某进程检查1个单元内容并发现它是假,该单元的内容就必须设置为真,而且必须在任何其他进程检查这个单元之前完成这一设置。
如果没有这种保证,则互斥元就会失效,类似于图3-29里有关银行账户的方式。  
test-and-set!的实际实现方式依赖于所用系统中运行并发进程的细节。例如,我们有可能是在1台顺序处理器上,采用在各进程间轮换的时间片机制执行并发进程,让每个进程运行很短一段时间,而后中断这一进程闭并转移到另1个进程去。在这种情况下,只需在检查和设置单元值之间禁止进行时间分片,test-and-set!就可以正确工作用了。在另一类操作中,多处理器计算机则提供了专门指令,直接在硬件中支持原子操作。
##流##
在试图模拟真实世界中的现象时,我们做了一些明显合理的决策:用具有局部状态的计算对象去模拟真实世界里具有局部状态的对象,用计算机里面随着时间的变化去表示真实世界里随着时间的变化,在计算机里,被模拟对象随着时间的变化是通过对那些模拟对象中局部变量的赋值实现的。  
如果以数学函数的方式考虑这些问题,我们可以将1个量x的随着时间去变化的行为,描述为1个时间的函数x(t).如果我们项集中关注的是1个个时刻的x,那么就可以将它看作1个变化着的量。然而,如果我们关注的是这些值的整个时间史,那么就不需要强调其中的变化——这一函数本身并没有改变。  
如果用离散的步长去度量时间,那么我们就可以用1个(可能无穷的)序列去模拟1个时间函数。在这一节里,我们将看到如何用这样的序列去模拟变化,以这种序列表示被模拟系统随着时间变化的历史。为了做到这些,我们需要引进一种称为流的新数据结构。从抽象的观点看,1个流也就是1个序列。然而我们发现,把流直接表示为表并不能完全揭示流处理的威力。作为1种替代形式,我们将要引进1种延时求值的技术,它将使我们能够用流去表示非常长的(甚至是无穷的)序列。  
流处理使我们去模拟一些包含状态的系统,但却不需要利用赋值或者变动数据。这一情况会产生一些重要的结果,既有理论的也有实际的。因此我们可以构造出一些模型,它们能避免由于引进了赋值而带来的内在缺陷。但是,流框架也带来它自己的困难。
###流作为延时的表###
流是1种非常巧妙的想法,使我们可能利用各种序列操作,但又不会带来将序列作为表去操作而引起的代价。利用流结构,我们能得到这2个世界里最好的东西,如此形成的程序可以像序列操作那么优雅,同时又能得到递归计算的效率。  
这里的基本想法就是做出1种安排,只是部分地构造出流的结构,并将这样的部分结构送给使用流的程序。如果使用者需要访问这个流的尚未构造出的那个部分,那么这个流就会自动地继续构造下去,但是只做出足够满足当时需要的那一部分。这一做法造成了1种假象,就好像整个流都存在着一样。换句话说,虽然下面将要写出各个程序都像是在处理完整的序列,但我们将要设计出流的1种实现,使得流的构造和它的使用能够交错进行,而这种交错又是完全透明的。  
从表面上看,流也就是表,但是对它们进行操作的过程的名字不同.在这里有构造函数cons-stream,还有2个选择函数stream-car和stream-cdr,它们满足如下的约束条件:

```
(stream-car (cons-stream x y))=x
(stream-cdr (cons-stream x y))=y
```

这里有1个可识别的对象the-empty-stream,它绝不会是任何cons-stream操作的结果。这个对象可以用谓语stream-null?判断。有了这些东西,我们就可以像构造和使用表一样,去构造和使用流,用流去表示汇聚在一个序列里的一批数据了。特别是我们将用与第2章的各种表操作的类似方式去构造流:

```
(define (stream-ref s n)
 (if (= n 0)
   (stream-car s)
   (stream-ref (stream-cdr s)(- n 1))))

(define (stream-map proc s)
 (if (stream-null? s)
  the-empty-stream
  (cons-stream (proc (stream-car s)
               (stream-map proc (stream-cdr s))))))

(define (stream-for-each proc s)
 (if (stream-null? s)
   'done
   (begin (proc (stream-car s))
          (stream-for-each proc (stream-cdr s)))))
```

stream-for-each对于考察1个流非常有用:

```
(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  （display x))
```

为了使流的实现能自动的、透明的完成1个流的构造和使用的交错进行,我们需要做出1种安排,使得对于流的cdr和求值要等到真正通过过程stream-cdr去访问它的时候再做,而不是在通过cons-stream构造流的时候做。这一实现选择让我们回忆起2.1.2节有关有理数的讨论。在流和常规表之间也存在着类似的关系,作为1种数据抽象,流和表完全一样,它们的不同点就在于元素的求值时间。对于常规的表,其car和cdr都是在构造时求值;而对于流,其cdr则是在选取的时候才去求值。  
我们的流实现将基于1种称为delay的特殊形式,对于(delay `<exp>`)的求值将不对表达式`<exp>`求值,而是返回1个称为延时对象的对象,它可以看作是对在未来的某个时间求值`<exp>`的允诺。和delay一起的还有1个称为force的过程,它以1个延时对象为参数,执行相应的求值工作。从效果上看,也就是迫使delay完成它所允诺的求值。下面就爱那个看到delay和force可以如何实现,现在我们先用它们来构造流。  
cons-stream是1个特殊形式,其定义将使

```
(cons-stream <a> <b>)
```

等价于

```
(cons <a> (delay <b>))
```

这就表示我们将用序对来构造流。不过,在这里并不是将流的后面部分放进序对的cdr,而是把如果需要就可以计算出有关部分的允诺放在那里。现在,stream-car和stream-cdr已经可以定义为如下的过程了:

```
(define (stream-car stream)(car stream))
(define (stream-cdr stream)(force (cdr stream)))
```

stream-car选取有关序对的car部分,stream-cdr选取有关序对的cdr部分,并求值这里的延时表达式,以获得这个流的后面部分。
###流实现的行为方式###
一般而言,可以将延时求值看作是1种由需求驱动的程序设计,其中流处理的每个阶段都仅仅活动到足够满足下一阶段需要的程度。


